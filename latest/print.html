<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Sway Programming Language</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">The Sway Programming Language</a></li><li class="chapter-item expanded "><a href="introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="introduction/installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="introduction/overview.html"><strong aria-hidden="true">1.2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="introduction/sway-toolchain.html"><strong aria-hidden="true">1.3.</strong> The Sway Toolchain</a></li><li class="chapter-item expanded "><a href="introduction/forc_project.html"><strong aria-hidden="true">1.4.</strong> A Forc Project</a></li></ol></li><li class="chapter-item expanded "><a href="examples/index.html"><strong aria-hidden="true">2.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/counter.html"><strong aria-hidden="true">2.1.</strong> Counter</a></li><li class="chapter-item expanded "><a href="examples/subcurrency.html"><strong aria-hidden="true">2.2.</strong> Subcurrency</a></li><li class="chapter-item expanded "><a href="examples/fizzbuzz.html"><strong aria-hidden="true">2.3.</strong> FizzBuzz</a></li><li class="chapter-item expanded "><a href="examples/wallet_smart_contract.html"><strong aria-hidden="true">2.4.</strong> Wallet Smart Contract</a></li></ol></li><li class="chapter-item expanded "><a href="sdks/index.html"><strong aria-hidden="true">3.</strong> SDK</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sdks/rust-sdk.html"><strong aria-hidden="true">3.1.</strong> Rust SDK</a></li><li class="chapter-item expanded "><a href="sdks/typescript-sdk.html"><strong aria-hidden="true">3.2.</strong> TypeScript SDK</a></li></ol></li><li class="chapter-item expanded "><a href="basics/index.html"><strong aria-hidden="true">4.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basics/overview.html"><strong aria-hidden="true">4.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="basics/variables.html"><strong aria-hidden="true">4.2.</strong> Variables</a></li><li class="chapter-item expanded "><a href="basics/built_in_types.html"><strong aria-hidden="true">4.3.</strong> Built-in Types</a></li><li class="chapter-item expanded "><a href="basics/custom_types.html"><strong aria-hidden="true">4.4.</strong> Custom Types</a></li><li class="chapter-item expanded "><a href="basics/functions.html"><strong aria-hidden="true">4.5.</strong> Functions</a></li><li class="chapter-item expanded "><a href="basics/reference_types.html"><strong aria-hidden="true">4.6.</strong> Reference Types</a></li></ol></li><li class="chapter-item expanded "><a href="control-flow/index.html"><strong aria-hidden="true">5.</strong> Control Flow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="control-flow/loops.html"><strong aria-hidden="true">5.1.</strong> Loops</a></li></ol></li><li class="chapter-item expanded "><a href="testing/index.html"><strong aria-hidden="true">6.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="testing/testing-with-rust.html"><strong aria-hidden="true">6.1.</strong> Testing with Rust</a></li></ol></li><li class="chapter-item expanded "><a href="sway-on-chain/index.html"><strong aria-hidden="true">7.</strong> Sway on the Chain</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sway-on-chain/program_types.html"><strong aria-hidden="true">7.1.</strong> Program Types</a></li><li class="chapter-item expanded "><a href="sway-on-chain/smart_contracts.html"><strong aria-hidden="true">7.2.</strong> Contracts</a></li><li class="chapter-item expanded "><a href="sway-on-chain/libraries.html"><strong aria-hidden="true">7.3.</strong> Libraries</a></li><li class="chapter-item expanded "><a href="sway-on-chain/scripts.html"><strong aria-hidden="true">7.4.</strong> Scripts</a></li><li class="chapter-item expanded "><a href="sway-on-chain/predicates.html"><strong aria-hidden="true">7.5.</strong> Predicates</a></li></ol></li><li class="chapter-item expanded "><a href="smart-contract-development/index.html"><strong aria-hidden="true">8.</strong> Smart Contract Development</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="smart-contract-development/storage.html"><strong aria-hidden="true">8.1.</strong> Contract Storage</a></li><li class="chapter-item expanded "><a href="smart-contract-development/purity.html"><strong aria-hidden="true">8.2.</strong> Function Purity</a></li></ol></li><li class="chapter-item expanded "><a href="advanced/index.html"><strong aria-hidden="true">9.</strong> Advanced Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced/generic_types.html"><strong aria-hidden="true">9.1.</strong> Generic Types</a></li><li class="chapter-item expanded "><a href="advanced/traits.html"><strong aria-hidden="true">9.2.</strong> Traits</a></li><li class="chapter-item expanded "><a href="advanced/trait_constraints.html"><strong aria-hidden="true">9.3.</strong> Trait Constraints</a></li><li class="chapter-item expanded "><a href="advanced/assembly.html"><strong aria-hidden="true">9.4.</strong> Assembly</a></li></ol></li><li class="chapter-item expanded "><a href="blockchain-concepts/index.html"><strong aria-hidden="true">10.</strong> Blockchain Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="blockchain-concepts/blockchain_types.html"><strong aria-hidden="true">10.1.</strong> Blockchain Types</a></li><li class="chapter-item expanded "><a href="blockchain-concepts/identifiers.html"><strong aria-hidden="true">10.2.</strong> Identifiers</a></li><li class="chapter-item expanded "><a href="blockchain-concepts/native_assets.html"><strong aria-hidden="true">10.3.</strong> Native Assets</a></li></ol></li><li class="chapter-item expanded "><a href="style/index.html"><strong aria-hidden="true">11.</strong> Conventions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="style/capitalization.html"><strong aria-hidden="true">11.1.</strong> Capitalization</a></li></ol></li><li class="chapter-item expanded "><a href="reference/index.html"><strong aria-hidden="true">12.</strong> Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/temporary_workarounds.html"><strong aria-hidden="true">12.1.</strong> Temporary Workarounds</a></li><li class="chapter-item expanded "><a href="reference/solidity_differences.html"><strong aria-hidden="true">12.2.</strong> Differences From Solidity</a></li><li class="chapter-item expanded "><a href="reference/rust_differences.html"><strong aria-hidden="true">12.3.</strong> Differences From Rust</a></li><li class="chapter-item expanded "><a href="reference/contributing_to_sway.html"><strong aria-hidden="true">12.4.</strong> Contributing To Sway</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Sway Programming Language</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/FuelLabs/sway" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-sway-programming-language"><a class="header" href="#the-sway-programming-language">The Sway Programming Language</a></h1>
<p>Sway is a domain-specific language (DSL) for the <a href="https://github.com/FuelLabs/fuel-specs">Fuel Virtual Machine (FuelVM)</a>, a blockchain-optimized VM designed for the Fuel blockchain. Sway is based on <a href="https://doc.rust-lang.org/book/">Rust</a>, and includes syntax to leverage a blockchain VM without needlessly verbose boilerplate.</p>
<p>This book documents how to write smart contracts in Sway, along with how to install and use the Sway toolchain.</p>
<p>Before starting developing smart contracts in Sway, please keep in mind the <a href="./reference/temporary_workarounds.html">temporary workarounds and missing features</a> of the language and toolchain.</p>
<h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>To get started with Forc and Sway start contract development, install the Sway toolchain and Fuel full node and set up your first project.</p>
<ul>
<li><a href="introduction/./installation.html">Installation</a></li>
<li><a href="introduction/./overview.html">Deploy a Sway contract</a></li>
<li><a href="introduction/./sway-toolchain.html">The Sway Toolchain</a></li>
<li><a href="introduction/./forc_project.html">A Forc Project</a></li>
</ul>
<h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>Note that if you want to run (e.g. for testing) Sway smart contracts, a Fuel Core full node is required. Otherwise, the Sway toolchain is sufficient to compile Sway smart contracts.</p>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>A prerequisite for installing and using Sway is the Rust toolchain. Platform-specific instructions can be found <a href="https://www.rust-lang.org/tools/install">here</a>.</p>
<p>Installing <code>fuel-core</code> may require installing additional system dependencies. See <a href="https://github.com/FuelLabs/fuel-core#building">here</a> for instructions.</p>
<h2 id="installing-from-cargo"><a class="header" href="#installing-from-cargo">Installing from Cargo</a></h2>
<p>The Sway toolchain and Fuel Core full node can be installed with:</p>
<pre><code class="language-sh">cargo install forc fuel-core
</code></pre>
<h3 id="updating-forc"><a class="header" href="#updating-forc">Updating <code>forc</code></a></h3>
<p>You can update <code>forc</code> and <code>fuel-core</code> with:</p>
<pre><code class="language-sh">cargo install forc fuel-core
</code></pre>
<h2 id="building-from-source"><a class="header" href="#building-from-source">Building from Source</a></h2>
<p>The Sway toolchain can be built from source by following instructions at <a href="https://github.com/FuelLabs/sway">https://github.com/FuelLabs/sway</a>.</p>
<p>The Fuel Core full node implementation can be built from source by following instructions at <a href="https://github.com/FuelLabs/fuel-core">https://github.com/FuelLabs/fuel-core</a>.</p>
<h2 id="enable-tab-completion-for-bash-fish-zsh-or-powershell"><a class="header" href="#enable-tab-completion-for-bash-fish-zsh-or-powershell">Enable tab completion for Bash, Fish, Zsh, or PowerShell</a></h2>
<p><code>forc</code> now supports generating completion scripts for Bash, Fish, Zsh, and PowerShell. See <code>forc completions --help</code> for full details, but the gist is as simple as using one of the following:</p>
<pre><code># Bash
$ forc completions --shell=bash &gt; ~/.local/share/bash-completion/completions/forc

# Bash (macOS/Homebrew)
$ forc completions --shell=bash &gt; $(brew --prefix)/etc/bash_completion.d/forc.bash-completion

# Fish
$ mkdir -p ~/.config/fish/completions
$ forc completions --shell=fish &gt; ~/.config/fish/completions/forc.fish

# Zsh
$ forc completions --shell=zsh &gt; ~/.zfunc/_forc

# PowerShell v5.0+
$ forc completions --shell=powershell &gt;&gt; $PROFILE.CurrentUserCurrentHost
# or
$ forc completions --shell=powershell | Out-String | Invoke-Expression
</code></pre>
<p>Once the completions have been generated and properly installed, close and reopen your terminal for the new completions to take effect.</p>
<h1 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h1>
<p>Follow this guide to write and deploy a simple wallet smart contract in Sway.</p>
<h2 id="glossary"><a class="header" href="#glossary">Glossary</a></h2>
<p>Before we begin, it may be helpful to understand terminology that will used throughout the docs and how they relate to each other:</p>
<ul>
<li><strong>Fuel</strong>: the Fuel blockchain.</li>
<li><strong>FuelVM</strong>: the virtual machine powering Fuel.</li>
<li><strong>Sway</strong>: the domain-specific language crafted for the FuelVM; it is inspired by Rust.</li>
<li><strong>Forc</strong>: the build system and package manager for Sway, similar to Cargo for Rust.</li>
</ul>
<p>Go <a href="introduction/./sway-toolchain.html">here</a> for more detailed information about each of these components.</p>
<h2 id="understand-sway-program-types"><a class="header" href="#understand-sway-program-types">Understand Sway Program Types</a></h2>
<p>There are four types of Sway programs:</p>
<ul>
<li>contract</li>
<li>predicate</li>
<li>script</li>
<li>library</li>
</ul>
<p>Contracts, predicates, and scripts can produce artifacts usable on the blockchain, while a library is simply a project designed for code reuse and is not directly deployable.</p>
<p>Every Sway file must begin with a declaration of what type of program it is.</p>
<h2 id="create-wallet-projects-with-forc"><a class="header" href="#create-wallet-projects-with-forc">Create Wallet Projects with <code>forc</code></a></h2>
<p>To deploy a wallet on Fuel, we will need to write a library, a contract, and a script in Sway.</p>
<p>First, let's <a href="introduction/./installation.html">install the Sway toolchain</a>. Then with <code>forc</code> installed, let's create three different sibling projects:</p>
<pre><code class="language-sh">forc init wallet_lib
forc init wallet_contract
forc init wallet_script
</code></pre>
<p>See <a href="introduction/./forc_project.html">here</a> for more information on Forc project structure.</p>
<h2 id="write-a-sway-smart-contract"><a class="header" href="#write-a-sway-smart-contract">Write a Sway Smart Contract</a></h2>
<h3 id="declare-abi-in-wallet_lib"><a class="header" href="#declare-abi-in-wallet_lib">Declare ABI in <code>wallet_lib</code></a></h3>
<p>Navigate into the <code>src/main.sw</code> file of the <code>wallet_lib</code> directory you just created.</p>
<p>Delete the auto-generated skeleton code currently in the file, and copy and paste the following code:</p>
<pre><code class="language-sway">library wallet_lib;

abi Wallet {
    fn receive_funds();
    fn send_funds(amount_to_send: u64, recipient_address: b256);
}
</code></pre>
<p>Every Sway file must start with a declaration of what type of program the file contains; here, we've declared that this file is a <code>library</code>.</p>
<p>Sway contracts should declare an ABI—an <strong>a</strong>pplication <strong>b</strong>inary <strong>i</strong>nterface in a library so that it can be re-used by downstream contracts. Let's focus on the ABI declaration and inspect it line-by-line.</p>
<p>In the first line, we declare the name of this ABI: <code>Wallet</code>. To import this ABI into either a script or another contract for calling the contract, or the contract to implement the ABI, you would use <code>use wallet_lib::Wallet;</code>.</p>
<p>In the second line we are declaring an ABI method called <code>receive_funds</code> which, when called, should receive funds into this wallet. This method takes no parameters and does not return anything.</p>
<p><em>Note that we are simply defining an interface here, so there is no_function body or implementation of the function. We only need to define the interface itself. In this way, ABI declarations are similar to <a href="introduction/../advanced/traits.html">Rust trait declarations</a>.</em></p>
<p>In the third line we are declaring another ABI method, this time called <code>send_funds</code>. It takes two parameters the amount to send, and the address to send the funds to.</p>
<h3 id="implementing-the-abi-methods-in-wallet_contract"><a class="header" href="#implementing-the-abi-methods-in-wallet_contract">Implementing the ABI Methods in <code>wallet_contract</code></a></h3>
<p>Now that we've defined the interface, let's discuss how to use it. We will start by implementing the above ABI for a specific contract.</p>
<p>To do this, navigate to the <code>wallet_contract</code> repo that you created with <code>forc</code> previously.</p>
<p>First, you need to import the <code>Wallet</code> declaration from the last step. Open up <code>Forc.toml</code>. It should look something like this:</p>
<pre><code class="language-toml">[project]
authors = [&quot;user&quot;]
entry = &quot;main.sw&quot;
license = &quot;Apache-2.0&quot;
name = &quot;wallet_contract&quot;

[dependencies]
core = { git = &quot;http://github.com/FuelLabs/sway-lib-core&quot; }
std = { git = &quot;http://github.com/FuelLabs/sway-lib-std&quot; }
</code></pre>
<p>Include the <code>wallet_lib</code> repo by adding the following line to the bottom of the file:</p>
<pre><code class="language-toml">wallet_lib = { path = &quot;../wallet_lib&quot; }
</code></pre>
<p>Now, open up <code>main.sw</code> in <code>wallet_contract/src</code> and copy and paste the following code:</p>
<pre><code class="language-sway">impl Wallet for Contract {
    fn receive_funds() {
    }

    fn send_funds(amount_to_send: u64, recipient_address: b256) {
    }
}
</code></pre>
<p>This implements the ABI methods with empty bodies. Actual implementation of the bodies is left as an exercise for the reader.</p>
<h2 id="build-the-contract"><a class="header" href="#build-the-contract">Build the Contract</a></h2>
<p>Build <code>wallet_contract</code> by running</p>
<pre><code class="language-sh">forc build
</code></pre>
<p>from inside the <code>wallet_contract</code> directory.</p>
<h2 id="deploy-the-contract"><a class="header" href="#deploy-the-contract">Deploy the Contract</a></h2>
<p>It's now time to deploy the wallet contract and call it on a Fuel node. We will show how to do this using <code>forc</code> from the command line, but you can also do it using the <a href="https://github.com/FuelLabs/fuels-rs#deploying-a-sway-contract">Rust SDK</a> or the <a href="https://github.com/FuelLabs/fuels-ts/#deploying-contracts">TypeScript SDK</a></p>
<h3 id="spin-up-a-fuel-node"><a class="header" href="#spin-up-a-fuel-node">Spin Up a Fuel node</a></h3>
<p>In a separate tab in your terminal, spin up a local Fuel node:</p>
<pre><code class="language-sh">Fuel-core --db-type in-memory
</code></pre>
<h3 id="deploy-wallet_contract-to-your-local-fuel-node"><a class="header" href="#deploy-wallet_contract-to-your-local-fuel-node">Deploy <code>wallet_contract</code> To Your Local Fuel Node</a></h3>
<p>To deploy <code>wallet_contract</code> on your local Fuel node, run</p>
<pre><code class="language-sh">forc deploy
</code></pre>
<p>from the root of the <code>wallet_contract</code> directory.</p>
<p>This should produce some output in <code>stdout</code> that looks like this:</p>
<pre><code class="language-console">$ forc deploy
  Compiled library &quot;wallet_lib&quot;.
  Compiled script &quot;wallet_contract&quot;.
  Bytecode size is 212 bytes.
Contract id: 0xf4b63e0e09cb72762cec18a6123a9fb5bd501b87141fac5835d80f5162505c38
Logs:
HexString256(HexFormatted(0xd9240bc439834bc6afc3f334abf285b3b733560b63d7ce1eb53afa8981984af7))
</code></pre>
<p>Note the contract ID — you will need below.</p>
<h2 id="write-a-sway-script-to-call-a-sway-contract"><a class="header" href="#write-a-sway-script-to-call-a-sway-contract">Write a Sway Script to Call a Sway Contract</a></h2>
<p><em>Note that if you are using the TypeScript SDK you do not need to write a script to call the Sway contract.</em></p>
<p>Now that we have deployed our wallet contract, we need to actually <em>call</em> our contract. We can do this by calling the contract from a script.</p>
<p>Let's navigate to the <code>wallet_script</code> directory created previously.</p>
<p>First, you need to import the <code>wallet_lib</code> library. Open up the <code>Forc.toml</code> in the root of the directory. Import <code>wallet_lib</code> repo by adding the following line to the bottom of the file:</p>
<pre><code class="language-toml">wallet_lib = { path = &quot;../wallet_lib&quot; }
</code></pre>
<p>Next, open up <code>src/main.sw</code>. Copy and paste the following code:</p>
<pre><code class="language-sway">script;

use wallet_lib::Wallet;
use std::constants::ETH_ID;

fn main() {
    let caller = abi(Wallet, &lt;contract_address&gt;);
    caller.send_funds(200, 0x9299da6c73e6dc03eeabcce242bb347de3f5f56cd1c70926d76526d7ed199b8b);
}
</code></pre>
<p>Replace <code>&lt;contract_address&gt;</code> with the contract ID you noted when deploying the contract.</p>
<p>The main new concept is the <em>abi cast</em>: <code>abi(AbiName, ContractAddress)</code>. This returns a <code>ContractCaller</code> type which can be used to call contracts. The methods of the ABI become the methods available on this contract caller: <code>send_funds</code> and <code>receive_funds</code>. We can directly call the contract ABI method as if it was just a regular function.</p>
<h2 id="check-that-wallet_script-builds"><a class="header" href="#check-that-wallet_script-builds">Check That <code>wallet_script</code> Builds</a></h2>
<p>To check that <code>wallet_script</code> builds successfully, run</p>
<pre><code class="language-sh">forc build
</code></pre>
<p>from the root of the <code>wallet_script</code> directory.</p>
<h2 id="call-the-contract"><a class="header" href="#call-the-contract">Call the Contract</a></h2>
<p>It's now time to call the contract. We will show how to do this using <code>forc</code> from the command line, but you can also do this using the <a href="https://github.com/FuelLabs/fuels-rs#deploying-a-sway-contract">Rust SDK</a> or the <a href="https://github.com/FuelLabs/fuels-ts/#calling-contracts">TypeScript SDK</a></p>
<h3 id="run-wallet_script-against-your-local-fuel-node"><a class="header" href="#run-wallet_script-against-your-local-fuel-node">Run <code>wallet_script</code> Against Your Local Fuel Node</a></h3>
<p>To run the script now against the local Fuel node, run</p>
<pre><code class="language-sh">forc run --contract &lt;contract-id&gt;
</code></pre>
<p>from the root of the <code>wallet_script</code> directory.</p>
<p>Note that we are passing in the <code>wallet_contract</code> contract ID as a command-line parameter. You will need to pass in the contract ID of every contract that this script will be interacting with.</p>
<p>If the script is successfully run, it will output something that looks like:</p>
<pre><code class="language-console">$ forc run --contract &lt;contract-id&gt;
  Compiled library &quot;lib-std&quot; with 7 warnings.
  Compiled library &quot;wallet_lib&quot;.
  Compiled script &quot;wallet_script&quot;.
  Bytecode size is 272 bytes.
[Call { id: 0xf4b63e0e09cb72762cec18a6123a9fb5bd501b87141fac5835d80f5162505c38, to: 0xf4b63e0e09cb72762cec18a6123a9fb5bd501b87141fac5835d80f5162505c38, amount: 0, color: 0x0000000000000000000000000000000000000000000000000000000000000000, gas: 10000, a: 1506869579, b: 968, pc: 1656, is: 1656 }, Return { id: 0xf4b63e0e09cb72762cec18a6123a9fb5bd501b87141fac5835d80f5162505c38, val: 0, pc: 1764, is: 1656 }, Return { id: 0x0000000000000000000000000000000000000000000000000000000000000000, val: 0, pc: 584, is: 472 }, ScriptResult { result: InstructionResult { reason: RESERV00, instruction: Instruction { op: 0, ra: 0, rb: 0, rc: 0, rd: 0, imm06: 0, imm12: 0, imm18: 0, imm24: 0 } }, gas_used: 998 }]
</code></pre>
<p>It returns a <code>Call</code> receipt and a <code>ScriptResult</code> receipt.</p>
<h2 id="testing-sway-contracts"><a class="header" href="#testing-sway-contracts">Testing Sway contracts</a></h2>
<p>The recommended way to test Sway contracts is via the <a href="introduction/../testing/testing-with-rust.html">Rust SDK</a>. You may also write tests in TypeScript if you are using the TypeScript SDK.</p>
<h1 id="the-sway-toolchain"><a class="header" href="#the-sway-toolchain">The Sway Toolchain</a></h1>
<p>The Sway toolchain consists of several components.</p>
<h2 id="forc-forc"><a class="header" href="#forc-forc">Forc (<code>forc</code>)</a></h2>
<p>The &quot;Fuel Orchestrator&quot; <a href="https://github.com/FuelLabs/sway/tree/master/forc">Forc</a> is our equivalent of Rust's <a href="https://doc.rust-lang.org/cargo/">Cargo</a>. It is the primary entry point for creating, building, testing, and deploying Sway projects.</p>
<h2 id="sway-language-server-forc-lsp"><a class="header" href="#sway-language-server-forc-lsp">Sway Language Server (<code>forc lsp</code>)</a></h2>
<p>The Sway Language Server <code>forc lsp</code> is provided to expose features to IDEs. Currently, only <a href="https://marketplace.visualstudio.com/items?itemName=FuelLabs.sway-vscode-plugin">Visual Studio Code is supported through a plugin</a>. Vim support is forthcoming, though <a href="https://github.com/FuelLabs/sway.vim">syntax highlighting is provided</a>.</p>
<p>Note that there is no need to manually run <code>forc lsp</code> (the plugin will automatically start it), however <code>forc</code> must be in your <code>$PATH</code>. To check if <code>forc</code> is in your <code>$PATH</code>, type <code>forc --help</code> in your terminal.</p>
<h2 id="fuel-core-fuel-core"><a class="header" href="#fuel-core-fuel-core">Fuel Core (<code>fuel-core</code>)</a></h2>
<p>While not directly part of the Sway toolchain, an implementation of the Fuel protocol, <a href="https://github.com/FuelLabs/fuel-core">Fuel Core</a>, is provided. Note that <a href="https://github.com/FuelLabs/fuels-rs">the SDK</a> will automatically start and stop an instance of the node during tests, so there is no need to manually run a node unless using Forc directly without the SDK.</p>
<h1 id="a-forc-project"><a class="header" href="#a-forc-project">A Forc Project</a></h1>
<p>To initialize a new project with Forc, use <code>forc init</code>:</p>
<pre><code class="language-sh">forc init hello_world
</code></pre>
<p>Here is the project that Forc has initialized:</p>
<pre><code class="language-console">$ cd hello_world
$ tree .
├── Cargo.toml
├── Forc.toml
├── src
│   └── main.sw
└── tests
    └── harness.rs
</code></pre>
<p><code>Forc.toml</code> is the <em>manifest file</em> (similar to <code>Cargo.toml</code> for Cargo or <code>package.json</code> for Node), and defines project metadata such as the project name and dependencies.</p>
<pre><code class="language-toml">[project]
authors = [&quot;Fuel Labs &lt;contact@fuel.sh&gt;&quot;]
entry = &quot;main.sw&quot;
license = &quot;Apache-2.0&quot;
name = &quot;hello_world&quot;

[dependencies]
std = { git = &quot;http://github.com/FuelLabs/sway-lib-std&quot;, branch = &quot;master&quot; }
core = { git = &quot;http://github.com/FuelLabs/sway-lib-core&quot;, branch = &quot;master&quot; }
</code></pre>
<p>Here are the contents of the only Sway file in the project, and the main entry point, <code>src/main.sw</code>:</p>
<pre><code class="language-sway">script;

fn main() {

}
</code></pre>
<p>The project is <em>script</em>, one of four different project types. For additional information on different project types, see <a href="introduction/../sway-on-chain/index.html">here</a>.</p>
<p>We now compile our project with <code>forc build</code>, passing the flag <code>--print-finalized-asm</code> to view the generated assembly:</p>
<pre><code class="language-console">$ forc build --print-finalized-asm
.program:
ji   i4
noop
DATA_SECTION_OFFSET[0..32]
DATA_SECTION_OFFSET[32..64]
lw   $ds $is 1
add  $ds $ds $is
ret  $zero                    ; main fn returns unit value
.data:

Compiled script &quot;hello_world&quot;.
Bytecode size is 28 bytes.
</code></pre>
<p>To run this script, use <code>forc run</code> (note that <code>fuel-core</code> must be running for this to work):</p>
<pre><code class="language-console">$ forc run
Bytecode size is 28 bytes.
[Return { id: ContractId([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), val: 0, pc: 488, is: 464 }]
</code></pre>
<p>Use <code>forc json-abi</code> to output the ABI of the contract. To write this to a <code>.json</code> file (which is necessary for running tests below), pipe it using something like:</p>
<pre><code class="language-sh">forc json-abi &gt; my-contract-abi.json
</code></pre>
<p>There is currently not a convention for where ABI files should be placed; one
common choice is loose in the root directory.</p>
<h1 id="example"><a class="header" href="#example">Example</a></h1>
<p>Some basic example contracts to see how Sway and Forc work.</p>
<ul>
<li><a href="examples/./counter.html">Counter</a></li>
<li><a href="examples/./subcurrency.html">Subcurrency</a></li>
<li><a href="examples/./fizzbuzz.html">FizzBuzz</a></li>
<li><a href="examples/./wallet_smart_contract.html">Wallet Smart Contract</a></li>
</ul>
<h1 id="counter"><a class="header" href="#counter">Counter</a></h1>
<p>The following is a simple example of a contract which implements a counter. Both the <code>initialize()</code> and <code>increment()</code> functions return the currently set value.</p>
<pre><code class="language-sway">contract;

use std::storage::{get, store};

const KEY = 0x0000000000000000000000000000000000000000000000000000000000000000;

abi Incrementor {
    fn initialize(initial_value: u64) -&gt; u64;
    fn increment(initial_value: u64) -&gt; u64;
}

impl Incrementor for Contract {
    fn initialize(initial_value: u64) -&gt; u64 {
        store(KEY, initial_value);
        initial_value
    }
    fn increment(increment_by: u64) -&gt; u64 {
        let new_val = get::&lt;u64&gt;(KEY) + 1;
        store(KEY, new_val);
        new_val
    }
}
</code></pre>
<h1 id="subcurrency"><a class="header" href="#subcurrency">Subcurrency</a></h1>
<pre><code class="language-sway">contract;

use std::chain::*;
use std::hash::*;
use std::storage::*;

////////////////////////////////////////
// Event declarations
////////////////////////////////////////

// Events allow clients to react to changes in the contract.
// Unlike Solidity, events are simply structs.
// Note: Serialization is not yet implemented, therefore logging
//  of arbitrary structures will not work without manual
//  serialization.

/// Emitted when a token is sent.
struct Sent {
    from: b256,
    to: b256,
    amount: u64,
}

////////////////////////////////////////
// ABI declarations
////////////////////////////////////////

/// ABI definition for a subcurrency.
abi Token {
    // Mint new tokens and send to an address.
    // Can only be called by the contract creator.
    fn mint(receiver: b256, amount: u64);

    // Sends an amount of an existing token.
    // Can be called from any address.
    fn send(sender: b256, receiver: b256, amount: u64);
}

////////////////////////////////////////
// Constants
////////////////////////////////////////

/// Address of contract creator.
const MINTER: b256 = 0x9299da6c73e6dc03eeabcce242bb347de3f5f56cd1c70926d76526d7ed199b8b;

////////////////////////////////////////
// Contract storage
////////////////////////////////////////

// Contract storage persists across transactions.
// Note: Contract storage variables are not implemented yet.

const STORAGE_BALANCES: b256 = 0x0000000000000000000000000000000000000000000000000000000000000000;

////////////////////////////////////////
// ABI definitions
////////////////////////////////////////

/// Contract implements the `Token` ABI.
impl Token for Contract {
    fn mint(receiver: b256, amount: u64) {
        // Note: authentication is not yet implemented, for now just trust params
        // See https://github.com/FuelLabs/sway/issues/195
        if receiver == MINTER {
            let storage_slot = hash_pair(STORAGE_BALANCES, MINTER, HashMethod::Sha256);

            let mut receiver_amount = get::&lt;u64&gt;(storage_slot);
            receiver_amount = receiver_amount + amount;
            store(storage_slot, receiver_amount);
        } else {
            // Revert with error `69`, chosen arbitrarily
            panic(69);
        }
    }

    fn send(sender: b256, receiver: b256, amount: u64) {
        let sender_storage_slot = hash_pair(STORAGE_BALANCES, sender, HashMethod::Sha256);

        let mut sender_amount = get::&lt;u64&gt;(sender_storage_slot);
        sender_amount = sender_amount - amount;
        store(sender_storage_slot, sender_amount);

        let receiver_storage_slot = hash_pair(STORAGE_BALANCES, receiver, HashMethod::Sha256);

        let mut receiver_amount = get::&lt;u64&gt;(receiver_storage_slot);
        receiver_amount = receiver_amount + amount;
        store(receiver_storage_slot, receiver_amount);
    }
}
</code></pre>
<h1 id="fizzbuzz"><a class="header" href="#fizzbuzz">FizzBuzz</a></h1>
<p>This example is not the traditional fizzbuzz, instead it is the smart contract version! A script can call this contract with some u64 value
and receive back its fizzbuzzability as an enum. Note that the deserialization scheme for the fizzbuzz enum will be included in the ABI descriptor
so the caller knows what to do with the bytes.</p>
<pre><code class="language-sway">contract;

enum FizzBuzzResult {
    Fizz: (),
    Buzz: (),
    FizzBuzz: (),
    Other: u64,
}

abi FizzBuzz {
    fn fizzbuzz(gas: u64, coins: u64, asset_id: b256, input: u64) -&gt; FizzBuzzResult;
}

impl FizzBuzz for Contract {
    fn fizzbuzz(gas: u64, coins: u64, asset_id: b256, input: u64) -&gt; FizzBuzzResult {
        if input % 15 == 0 {
            FizzBuzzResult::FizzBuzz
        } else if input % 3 == 0 {
            FizzBuzzResult::Fizz
        } else if input % 5 == 0 {
            FizzBuzzResult::Buzz
        } else {
            FizzBuzzResult::Other(input)
        }
    }
}
</code></pre>
<h1 id="wallet-smart-contract"><a class="header" href="#wallet-smart-contract">Wallet Smart Contract</a></h1>
<p><em>Contract storage in the language syntax is a work-in-progress feature, and the following example does not currently compile.</em></p>
<pre><code class="language-sway">// NOTE: Storage is a work in progress (see
// https://github.com/FuelLabs/sway/pull/646), but once it is implemented,
// declaring storage should look like this.

contract;

use std::*;
use std::chain::assert;

const OWNER_ADDRESS: b256 = 0x8900c5bec4ca97d4febf9ceb4754a60d782abbf3cd815836c1872116f203f861;
const ETH_ID: b256 = 0x0000000000000000000000000000000000000000000000000000000000000000;

// storage {
//     balance: u64,
// }

abi Wallet {
    fn receive_funds();
    fn send_funds(amount_to_send: u64, recipient_address: b256);
}

impl Wallet for Contract {
    fn receive_funds() {
        // if asset_id == ETH_ID {
        //     let balance = storage.balance.write();
        //     deref balance = balance + coins_to_forward;
        // };
    }

    fn send_funds(amount_to_send: u64, recipient_address: b256) {
        // assert(sender() == OWNER_ADDRESS);
        // assert(storage.balance &gt; req.amount_to_send);
        // storage.balance = storage.balance - req.amount_to_send;
        // transfer_coins(asset_id, req.recipient_address, req.amount_to_send);
    }
}
</code></pre>
<h1 id="sdk"><a class="header" href="#sdk">SDK</a></h1>
<p>We currently provide SDK's for Rust and TypeScript.</p>
<ul>
<li><a href="sdks/./rust-sdk.html">Rust SDK</a></li>
<li><a href="sdks/./typescript-sdk.html">TypeScript SDK</a></li>
</ul>
<h1 id="rust-sdk"><a class="header" href="#rust-sdk">Rust SDK</a></h1>
<p>The Rust SDK supports common tasks like:</p>
<ul>
<li>Programmatically compiling Sway code</li>
<li>Launching Fuel nodes</li>
<li>Deploying contracts</li>
<li>Interacting with deployed contracts</li>
<li>Running Sway scripts</li>
<li>Generating Type-safe Sway contract bindings</li>
<li>CLI for common operations</li>
<li><a href="sdks/./testing/testing-with-rust.html">Testing</a></li>
</ul>
<p>Refer <a href="https://github.com/FuelLabs/fuels-rs">here</a> for full documentation.</p>
<h1 id="typescript-sdk"><a class="header" href="#typescript-sdk">TypeScript SDK</a></h1>
<p>The TypeScript SDK supports common tasks like:</p>
<ul>
<li>Deploying and calling contracts</li>
<li>Generating contract types with TypeChain</li>
<li>Building and sending transactions</li>
<li>Encoding and decoding contract ABI</li>
</ul>
<p>Refer <a href="https://github.com/FuelLabs/fuels-ts">here</a> for full documentation.</p>
<h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>Sway basics.</p>
<ul>
<li><a href="basics/./overview.html">Overview</a></li>
<li><a href="basics/./variables.html">Variables</a></li>
<li><a href="basics/./built_in_types.html">Built-in Types</a></li>
<li><a href="basics/./custom_types.html">Custom Types</a></li>
<li><a href="basics/./blockchain_types.html">Blockchain Types</a></li>
<li><a href="basics/./functions.html">Functions</a></li>
<li><a href="basics/./reference_types.html">Reference Types</a></li>
</ul>
<h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>Sway is a programming language designed for the FuelVM. It is a statically typed, compiled language with type inference
and traits. Sway aims to make smart contract development safer and more performant through the use of strong static 
analysis and compiler feedback.</p>
<h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>Variables in Sway are <em>immutable by default</em>. This means that, by default, once a variable is declared, its value cannot change. This is one of how Sway encourages safe programming, and many modern languages have this same default. Let's take a look at variables in detail.</p>
<h2 id="declaring-a-variable"><a class="header" href="#declaring-a-variable">Declaring a Variable</a></h2>
<p>Let's look at a variable declaration:</p>
<pre><code class="language-sway">let foo = 5;
</code></pre>
<p>Great! We have just declared a variable, <code>foo</code>. What do we know about <code>foo</code>?</p>
<ol>
<li>It is immutable.</li>
<li>Its value is <code>5</code>.</li>
<li>Its type is <code>u64</code>, a 64-bit unsigned integer.</li>
</ol>
<p><code>u64</code> is the default numeric type, and represents a 64-bit unsigned integer. See the section <a href="basics/./built_in_types.html">Built-in Types</a> for more details.</p>
<p>We can also make a mutable variable. Let's take a look:</p>
<pre><code class="language-sway">let mut foo = 5;
foo = 6;
</code></pre>
<p>Now, <code>foo</code> is mutable, and the reassignment to the number <code>6</code> is valid. That is, we are allowed to <em>mutate</em> the variable <code>foo</code> to change its value.</p>
<h2 id="type-annotations"><a class="header" href="#type-annotations">Type annotations</a></h2>
<p>A variable declaration can contain a <em>type annotation</em>. A type annotation serves the purpose of declaring the type, in addition to the value, of a variable. Let's take a look:</p>
<pre><code class="language-sway">let foo: u32 = 5;
</code></pre>
<p>We have just declared the <em>type</em> of the variable <code>foo</code> as a <code>u32</code>, which is an unsigned 32-bit integer. Let's take a look at a few other type annotations:</p>
<pre><code class="language-sway">let bar: str[4] = &quot;sway&quot;;
let baz: bool = true;
</code></pre>
<p>If the value declared cannot be assigned to the declared type, there will be an error generated by the compiler.</p>
<h1 id="built-in-types"><a class="header" href="#built-in-types">Built-in Types</a></h1>
<p>Every value in Sway is of a certain type. Although deep down, all values are just ones and zeroes in silicon, Sway needs to know what those ones and zeroes actually mean. This is accomplished with <em>types</em>.</p>
<p>Sway is a statically typed language. At compile time, the types of every value must be known. This does not mean you need to specify every single type: usually, the type can be reasonably inferred.</p>
<h2 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h2>
<p>Sway has the following primitive types:</p>
<ol>
<li><code>u8</code> (8-bit unsigned integer)</li>
<li><code>u16</code> (16-bit unsigned integer)</li>
<li><code>u32</code> (32-bit unsigned integer)</li>
<li><code>u64</code> (64-bit unsigned integer)</li>
<li><code>str[]</code> (fixed-length string)</li>
<li><code>bool</code> (Boolean <code>true</code> or <code>false</code>)</li>
<li><code>b256</code> (256 bits (32 bytes), i.e. a hash)</li>
</ol>
<p>All other types in Sway are built up of these primitive types, or references to these primitive types. You may notice that there are no signed integers—this is by design. In the blockchain domain that Sway occupies, floating-point values and negative numbers have smaller utility, so their implementation has been left up to libraries for specific use cases.</p>
<h2 id="numeric-types"><a class="header" href="#numeric-types">Numeric Types</a></h2>
<p>All of the unsigned integer types are numeric types, and the <code>byte</code> type can also be viewed as an 8-bit unsigned integer.</p>
<p>Numbers can be declared with binary syntax, hexadecimal syntax, base-10 syntax, and underscores for delineation. Let's take a look at the following valid numeric primitives:</p>
<pre><code class="language-sway">0xffffff    // hexadecimal
0b10101010  // binary
10          // base-10
100_000     // underscore delineated base-10
0x1111_0000 // underscore delineated binary
0xfff_aaa   // underscore delineated hexadecimal
</code></pre>
<p>The default numeric type is <code>u64</code>. The FuelVM's word size is 64 bits, and the cases where using a smaller numeric type saves space are minimal.</p>
<h2 id="boolean-type"><a class="header" href="#boolean-type">Boolean Type</a></h2>
<p>The boolean type (<code>bool</code>) has two potential values: <code>true</code> or <code>false</code>. Boolean values are typically used for conditional logic or validation, for example in <code>if</code> expressions. Booleans can be negated, or flipped, with the unary negation operator <code>!</code>. For example:</p>
<pre><code class="language-sway">fn returns_false() -&gt; bool {
  let boolean_value: bool = true;
  !boolean_value
}
</code></pre>
<h2 id="string-type"><a class="header" href="#string-type">String Type</a></h2>
<p>In Sway, static-length strings are a primitive type. This means that when you declare a string, its size is a part of its type. This is necessary for the compiler to know how much memory to give for the storage of that data. The size of the string is denoted with square brackets. Let's take a look:</p>
<pre><code class="language-sway">let my_string: str[4] = &quot;fuel&quot;;
</code></pre>
<p>Because the string literal <code>&quot;fuel&quot;</code> is four letters, the type is <code>str[4]</code>, denoting a static length of 4 characters. Strings default to UTF-8 in Sway.</p>
<h2 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h2>
<p><em>Compound types</em> are types that group multiple values into one type. In Sway, we have arrays and tuples.</p>
<h2 id="tuple-types"><a class="header" href="#tuple-types">Tuple Types</a></h2>
<p><em>note: tuples are a work in progress and are tracked by <a href="https://github.com/FuelLabs/sway/pull/399">this PR</a></em></p>
<p>A tuple is a general-purpose static-length aggregation of types. In more plain terms, a tuple is a single type that consists of an aggregate of zero or more types. The internal types that make up a tuple, and the tuple's cardinality, define the tuple's type. Let's take a look at some examples.</p>
<pre><code class="language-sway">let x: (u64, u64) = (0, 0);
</code></pre>
<p>This is a tuple, denoted by parenthesized, comma-separated values. Note that the type annotation, <code>(u64, u64)</code>, is similar in syntax to the expression which instantiates that type, <code>(0, 0)</code>.</p>
<pre><code class="language-sway">let x: (u64, bool) = (42, true);
assert(x.1)
</code></pre>
<p>In this example, we have created a new tuple type, <code>(u64, bool)</code>, which is a composite of a <code>u64</code> and a <code>bool</code>. To access a value within a tuple, we use <em>tuple indexing</em>: <code>x.1</code> stands for the first (zero-indexed, so the <code>bool</code>) value of the tuple. Likewise, <code>x.0</code> would be the zeroth, <code>u64</code> value of the tuple. Tuple values can also be accessed via destructuring:</p>
<pre><code class="language-sway">struct Foo {}
let x: (u64, Foo, bool) = (42, Foo {}, true);
let (number, foo, boolean) = x;
</code></pre>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<p>An array is similar to a tuple, but an array's values must all be of the same type. An array is written as a comma-separated list inside square brackets:</p>
<pre><code class="language-sway">let x = [1, 2, 3, 4, 5];
</code></pre>
<p>Arrays are allocated on the stack since their size is known. An array's size is <em>always</em> static, i.e. it cannot change. An array of five elements cannot become an array of six elements.</p>
<p>Arrays can be iterated over, unlike tuples. A common use case for arrays is checking set membership. If you are given a name, and you'd like to figure out if that name is included in your list of classmates, you can use an array:</p>
<pre><code class="language-sway">let name = /* some user input */;
let classmates = [&quot;Bob&quot;, &quot;Jan&quot;, &quot;Ron&quot;];
assert(classmates.contains(name));
</code></pre>
<p>An array's type is written as the type the array contains followed by the number of elements, semicolon-separated and within square brackets.</p>
<pre><code class="language-sway">let x: [u64; 5] = [0, 1, 2, 3, 4];
</code></pre>
<p>To access an element in an array, use <em>array indexing syntax</em>:</p>
<pre><code class="language-sway">let x: [bool; 2] = [true, false];

assert(x[0]);
</code></pre>
<p>Note that arrays are zero-indexed, just like tuples.</p>
<h1 id="custom-types"><a class="header" href="#custom-types">Custom Types</a></h1>
<h2 id="structs"><a class="header" href="#structs">Structs</a></h2>
<p>Structs in Sway are a named grouping of types. You may also be familiar with structs via another name: <em>product types</em>. Sway does not make any significantly unique usages of structs; they are similar to most other languages which have structs. If you're coming from an object-oriented background, a struct is like the data attributes of an object.</p>
<p>To declare a struct type, use <em>struct declaration syntax</em>:</p>
<pre><code class="language-sway">struct Foo {
    bar: u64,
    baz: bool,
}
</code></pre>
<p>This is saying that we have some structure named <code>Foo</code>. <code>Foo</code> has two fields: <code>bar</code>, a <code>u64</code>; and <code>baz</code>, a <code>bool</code>. To instantiate the structure <code>Foo</code>, we can use <em>struct instantiation syntax</em>, which is very similar to the declaration syntax except with expressions in place of types.</p>
<pre><code class="language-sway">let foo = Foo {
    bar: 42,
    baz: false,
};
</code></pre>
<p>To access a field of a struct, use <em>struct field access syntax</em>:</p>
<pre><code class="language-sway">// Instantiate `foo`.
let foo = Foo {
    bar: 42,
    baz: true,
};

// Access field `baz` of `foo`.
assert(foo.baz);
</code></pre>
<h3 id="struct-memory-layout"><a class="header" href="#struct-memory-layout">Struct Memory Layout</a></h3>
<p><em>This information is not vital if you are new to the language, or programming in general.</em></p>
<p>Structs have zero memory overhead. What that means is that in memory, each struct field is laid out sequentially. No metadata regarding the struct's name or other properties is preserved at runtime. In other words, structs are compile-time constructs. This is the same in Rust, but different in other languages with runtimes like Java.</p>
<h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<p><em>Enumerations</em>, or <em>enums</em>, are also known as <em>sum types</em>. An enum is a type that could be one of several variants. To declare an enum, you enumerate all potential variants. Let's look at <em>enum declaration syntax</em>:</p>
<pre><code class="language-sway">enum Color {
    Blue   : (),
    Green  : (),
    Red    : (),
    Silver : (),
    Grey   : (),
}
</code></pre>
<p>Here, we have defined five potential colors. Each enum variant is just the color name. As there is no extra data associated with each variant, we say that each variant is of type <code>()</code>, or unit. It is also possible to have an enum variant contain extra data. Take a look at this more substantial example, which combines struct declarations with enum variants:</p>
<pre><code class="language-sway">use std::collections::Vec;
use inventory_system::InventoryItem;
use inventory_system::Insurer;

struct Claim {
    insurance_company: Insurer,
    item_number: u64,
    item_cost: u64,
}

struct Receipt {
    customer: CustomerId,
    items_purchased: Vec&lt;InventoryItem&gt;,
}

struct Refund {
    customer: CustomerId,
    items_returned: Vec&lt;InventoryItem&gt;,
}

enum InventoryEvent {
    CustomerPurchase : Receipt,
    ItemLoss         : Claim,
    CustomerReturn   : Refund,
}
</code></pre>
<pre><code class="language-sway">enum Color {
    Blue   : (),
    Green  : (),
    Red    : (),
    Silver : (),
    Grey   : (),
}

fn main() {
    let color = Color::Blue;
}
</code></pre>
<p>Here, we have instantiated a variable named <code>color</code> with <em>enum instantiation syntax</em>. Note that enum instantiation does not require the <code>~</code> tilde syntax. If we wanted to instantiate an enum with some interior data, it looks like this:</p>
<pre><code class="language-sway">struct Claim {
    insurance_company: Insurer,
    item_number: u64,
    item_cost: u64,
}

let event = InventoryEvent::ItemLoss(Claim {
    insurance_company: ~Insurer::default(),
    item_number: 42,
    item_cost: 1_000,
});
</code></pre>
<h3 id="enum-memory-layout"><a class="header" href="#enum-memory-layout">Enum Memory Layout</a></h3>
<p><em>This information is not vital if you are new to the language, or programming in general.</em></p>
<p>Enums do have some memory overhead. To know which variant is being represented, Sway stores a one-word (8-byte) tag for the enum variant. The space reserved after the tag is equivalent to the size of the <em>largest</em> enum variant. So, to calculate the size of an enum in memory, add 8 bytes to the size of the largest variant. For example, in the case of <code>Color</code> above, where the variants are all <code>()</code>, the size would be 8 bytes since the size of the largest variant is 0 bytes.</p>
<h2 id="methods-and-associated-functions"><a class="header" href="#methods-and-associated-functions">Methods and Associated Functions</a></h2>
<p><em>Methods</em> are functions that are associated with a specific type and either refer to that type or mutate it. <em>Associated functions</em> are very similar, but they do not use any of the data in the type. Associated functions could be standalone functions, but they
are included in a specific type for organizational or semantic reasons.</p>
<p>To declare methods and associated functions for a struct or enum, use an <em>impl block</em>. Here, <code>impl</code> stands for implementation.</p>
<pre><code class="language-sway">script;

struct Foo {
    bar: u64,
    baz: bool,
}

impl Foo {
    // this is a _method_, as it takes `self` as a parameter.
    fn is_baz_true(self) -&gt; bool {
        self.baz
    }

    // this is an _associated function_, since it does not take `self` as a parameter.
    fn new_foo(number: u64, boolean: bool) -&gt; Foo {
      Foo {
          bar: number,
          baz: boolean,
      }
    }
}

fn main() {
    let foo = ~Foo::new_foo(42, true);
    assert(foo.is_baz_true());
}
</code></pre>
<p>Note the syntax of the associated function call: <code>~Foo::new_foo(42, true);</code>. This bit of syntax is unique to Sway: when referring to a type directly, you preface the type with a tilde (<code>~</code>). To call an associated function, refer to the type and then the function name.
To call a method, simply use dot syntax: <code>foo.iz_baz_true()</code>.</p>
<h2 id="syntax-examples"><a class="header" href="#syntax-examples">Syntax Examples</a></h2>
<pre><code class="language-sway">enum Color {
    Blue   : (),
    Green  : (),
    Red    : (),
    Silver : (),
    Grey   : (),
    // etc...
}

enum Make {
    Ford      : (),
    Toyota    : (),
    Mazda     : (),
    Chevrolet : (),
    BMW       : (),
    // etc...
}
struct Car {
    make: CarMake,
    color: Color,
}
</code></pre>
<h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions in Sway are declared with the <code>fn</code> keyword. Let's take a look:</p>
<pre><code class="language-sway">fn equals(first_param: u64, second_param: u64) -&gt; bool {
    first_param == second_param
}
</code></pre>
<p>We have just declared a function named <code>equals</code> which takes two parameters: <code>first_param</code> and <code>second_param</code>. This function also returns a <code>bool</code> value, i.e. either <code>true</code> or <code>false</code>. This function returns <code>true</code> if the two given parameters are equal, and <code>false</code> if they are not. If we want to use this function, we can do so like this:</p>
<pre><code class="language-sway">fn main() {
    equals(5, 5); // evaluates to `true`
    equals(5, 6); // evaluates to `false`
}
</code></pre>
<h1 id="reference-types"><a class="header" href="#reference-types">Reference Types</a></h1>
<p>If you have familiarity with references, also called pointers, from other languages, Sway references are no different. If you're new to this concept, this chapter is for you!</p>
<p>Memory in a computer is held in RAM. When you buy a Macbook Pro 16GB, for example, that 16GB number is referring to the <em>memory</em>, or <em>RAM</em>, available. In the FuelVM, we also have memory. When you instantiate a variable in a Sway program, it is written to some spot in memory. We need to keep track of <em>where</em> exactly that value was written to utilize it, though.</p>
<p>Every single byte in FuelVM memory has a name. The first byte's name is <code>0x01</code>. The second byte's name is <code>0x02</code>. The 54,321st byte's name is <code>0xD431</code><sup class="footnote-reference"><a href="#1">1</a></sup>. A reference is a variable that contains the name of a specific location in the FuelVM's memory. This is useful if you want to reason about the memory which contains the value and not the value itself.</p>
<pre><code class="language-sway">script;
fn main() {
    let x = 42;
    let reference_to_x = ref x;
}
</code></pre>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Check out <a href="https://en.wikipedia.org/wiki/Hexadecimal">this article</a> if you're not used to seeing numbers with letters in them.</p>
</div>
<h2 id="dereferencing"><a class="header" href="#dereferencing">Dereferencing</a></h2>
<h2 id="storage-references"><a class="header" href="#storage-references">Storage References</a></h2>
<h2 id="implicit-references"><a class="header" href="#implicit-references">Implicit References</a></h2>
<p>Types larger than one word in size are implicitly reference types.</p>
<h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<p>Sway control flow.</p>
<ul>
<li><a href="control-flow/./loops.html">Loops</a></li>
</ul>
<h1 id="loops"><a class="header" href="#loops">Loops</a></h1>
<h2 id="while"><a class="header" href="#while">While</a></h2>
<p>Loops in Sway are currently limited to <code>while</code> loops. This is what they look like:</p>
<pre><code class="language-sway">while counter &lt; 10 {
    counter = counter + 1;
}
</code></pre>
<p>You need the <code>while</code> keyword, some condition (<code>value &lt; 10</code> in this case) which will be evaluated each iteration, and a block of code inside the curly braces (<code>{...}</code>) to execute each iteration.</p>
<h3 id="break--continue"><a class="header" href="#break--continue">Break &amp; Continue</a></h3>
<p>There are no <code>break</code> or <code>continue</code> keywords yet, but they're coming.</p>
<p>For now, the way to break out of a <code>while</code> loop early is to manually invalidate the condition. In this case, that just means setting <code>counter</code> to be &gt;= 10.</p>
<p>Building on the previous example, here's what that might look like:</p>
<pre><code class="language-sway">let mut break_early = false;
while counter &lt; 10 {
    if break_early == true {
        // here we ensure the condition will evaluate to false, breaking the loop
        counter = 10
    } else {
        // calling some other function to set the bool value
        break_early = get_bool_value();
        counter = counter + 1
    }
}
</code></pre>
<h3 id="nested-loops"><a class="header" href="#nested-loops">Nested loops</a></h3>
<p>You can also use nested <code>while</code> loops if needed:</p>
<pre><code class="language-sway">while condition_1 == true {
    // do stuff...
    while condition_2 == true {
        // do more stuff...
    }
}
</code></pre>
<h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>There are a couple options for testing your Sway contract:</p>
<ul>
<li><a href="testing/./testing-with-rust.html">Testing with Rust</a></li>
<li><a href="testing/./testing-with-typescript.html">Testing with TypeScript</a></li>
</ul>
<h1 id="testing-with-rust"><a class="header" href="#testing-with-rust">Testing with Rust</a></h1>
<p>If you look again at the project structure when you create a <a href="testing/../getting-started/forc_project.html">new Forc project</a> with <code>forc init</code>, you can see a directory called <code>tests/</code>:</p>
<pre><code class="language-plaintext">$ forc init my-fuel-project
$ cd my-fuel-project
$ tree .
├── Cargo.toml
├── Forc.toml
├── src
│   └── main.sw
└── tests
    └── harness.rs
</code></pre>
<p>Note that this is a Rust package, hence the existence of a <code>Cargo.toml</code> (Rust manifest file) in the project root directory. The <code>Cargo.toml</code> in the root directory contains necessary Rust dependencies to enable you to write Rust-based tests using our <a href="https://github.com/FuelLabs/fuels-rs">Rust SDK</a> (<code>fuels-rs</code>).</p>
<p>These tests can be run using either <code>cargo test</code>, or <code>forc test</code> which will look for Rust tests under the <code>tests/</code> directory (created automatically with <code>forc init</code>).</p>
<p>For example, let's write tests against the following contract, written in Sway. This can be done in the pregenerated <code>src/main.sw</code> or in a new file in <code>src</code>. In the case of the latter, update the <code>entry</code> field in <code>Forc.toml</code> to point at the new contract.</p>
<pre><code class="language-sway">contract;

use std::constants::*;
use std::storage::*;

abi TestContract {
    fn initialize_counter(value: u64) -&gt; u64;
    fn increment_counter(amount: u64) -&gt; u64;
}

const SLOT = 0x0000000000000000000000000000000000000000000000000000000000000000;

impl TestContract for Contract {
    fn initialize_counter(value: u64) -&gt; u64 {
        store(SLOT, value);
        value
    }

    fn increment_counter(amount: u64) -&gt; u64 {
        let storedVal: u64 = get(SLOT);
        let value = storedVal + amount;
        store(SLOT, value);
        value
    }
}
</code></pre>
<p>Our <code>tests/harness.rs</code> file could look like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fuel_core::services::Config;
use fuel_tx::Salt;
use fuels_abigen_macro::abigen;
use fuels_contract::contract::Contract;
use fuels_signers::provider::Provider;
use rand::rngs::StdRng;
use rand::{Rng, SeedableRng};

// Generate Rust bindings from our contract JSON ABI
// FIXME: Incorrect path, see https://github.com/FuelLabs/fuels-rs/issues/94
abigen!(MyContract, &quot;./out/hello_world-abi.json&quot;);

#[tokio::test]
async fn harness() {
    let rng = &amp;mut StdRng::seed_from_u64(2322u64);

    // Build the contract
    let salt: [u8; 32] = rng.gen();
    let salt = Salt::from(salt);

    // Launch a local network and deploy the contract
    let compiled = Contract::compile_sway_contract(&quot;./&quot;, salt).unwrap();
    let client = Provider::launch(Config::local_node()).await.unwrap();
    let contract_id = Contract::deploy(&amp;compiled, &amp;client).await.unwrap();
    println!(&quot;Contract deployed @ {:x}&quot;, contract_id);

    let contract_instance = MyContract::new(contract_id.to_string(), client);

    // Call `initialize_counter()` method in our deployed contract.
    // Note that, here, you get type-safety for free!
    let result = contract_instance
        .initialize_counter(42)
        .call()
        .await
        .unwrap();

    assert_eq!(42, result.value);

    // Call `increment_counter()` method in our deployed contract.
    let result = contract_instance
        .increment_counter(10)
        .call()
        .await
        .unwrap();

    assert_eq!(52, result.value);
}
<span class="boring">}
</span></code></pre></pre>
<p>Then, in the root of our project, running <code>forc test</code> or <code>cargo test</code> will run the test above, compiling and deploying the contract to a local Fuel network, and calling the ABI methods against the contract deployed in there:</p>
<pre><code class="language-plaintext">$ forc test

running 1 test
test harness ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.64s
</code></pre>
<p>Instead of writing tests in Rust, tests can also be written in TypeScript using our <a href="https://github.com/FuelLabs/fuels-ts/">TypeScript SDK</a>.</p>
<h1 id="sway-on-the-chain"><a class="header" href="#sway-on-the-chain">Sway on the Chain</a></h1>
<ul>
<li><a href="sway-on-chain/./program_types.html">Program Types</a></li>
<li><a href="sway-on-chain/./smart_contracts.html">Contracts</a></li>
<li><a href="sway-on-chain/./libraries.html">Libraries</a></li>
<li><a href="sway-on-chain/./scripts.html">Scripts</a></li>
<li><a href="sway-on-chain/./predicates.html">Predicates</a></li>
</ul>
<h1 id="program-types"><a class="header" href="#program-types">Program Types</a></h1>
<p>Sway is fundamentally a blockchain language. Because of this, it has some features and requirements that you may not have seen in general-purpose programming languages.</p>
<p>A Sway program itself has a type: it is either a <em>contract</em>, a <em>predicate</em>, a <em>script</em>, or a <em>library</em>. The first three of these things are all deployable to the blockchain. A <em>library</em> is simply a project designed for code reuse and is never directly deployed to the chain.</p>
<p>Every Sway file <em>must</em> begin with a declaration of what type of program it is. A project can have many libraries within it, but only one contract, script, or predicate. Scripts and predicates require <code>main</code> functions to serve as entry points, while contracts instead publish an ABI. This chapter will go into detail about all of these various types of programs and what purposes they serve.</p>
<p>Contracts are used primarily for protocols or systems that operate within a fixed set of rules. A good example would be a staking contract or a decentralized exchange.</p>
<p>Scripts are used for complex on-chain interactions that won't persist. An example of this may be using a DEX and Lender to create a leveraged position (borrow, swap, re-collateralize, borrow) which is a complex transaction that would usually take multiple steps.</p>
<p>Libraries are for code that is reusable and useful for handling common situations. A good example of this would be a library to handle floating-point math or avoiding phantom overflow for <code>u64</code>.</p>
<h1 id="what-is-a-smart-contract"><a class="header" href="#what-is-a-smart-contract">What is a Smart Contract?</a></h1>
<p>A smart contract is no different than a script or predicate in that it is a piece of bytecode that is deployed to the blockchain via a <a href="https://github.com/FuelLabs/fuel-specs/blob/master/specs/protocol/tx_format.md">transaction</a>. The main features of a smart contract that differentiate it from scripts or predicates are that it is <em>callable</em> and <em>stateful</em>. Put another way, a smart contract is analogous to a deployed API with some database state. The interface of a smart contract, also just called a contract, must be defined strictly with an <a href="sway-on-chain/smart_contracts.html#abi-declarations">ABI declaration</a>. See <a href="sway-on-chain/../examples/subcurrency.html">this contract</a> for an example.</p>
<h2 id="syntax-of-a-smart-contract"><a class="header" href="#syntax-of-a-smart-contract">Syntax of a Smart Contract</a></h2>
<p>As with any Sway program, the program starts with a declaration of what <a href="sway-on-chain/./program_types.html">program type</a> it is. A contract must also either define or import an <a href="sway-on-chain/smart_contracts.html#abi-declarations">ABI declaration</a> and implement it. It is considered good practice to define your ABI in a separate library and import it into your contract. This allows callers of your contract to simply import the ABI directly and use it in their scripts to call your contract. Let's take a look at an ABI declaration in a library:</p>
<pre><code class="language-sway">library wallet_abi;

abi Wallet {
    fn receive_funds();
    fn send_funds(amount_to_send: u64, recipient_address: b256);
}
</code></pre>
<p>There are two declarations going on here. One is a struct representing the data that <code>send_funds</code> needs and the other is the ABI declaration. Let's focus on the ABI declaration and inspect it line-by-line.</p>
<h3 id="the-abi-declaration"><a class="header" href="#the-abi-declaration">The ABI Declaration</a></h3>
<pre><code class="language-sway">abi Wallet {
    fn receive_funds();
    fn send_funds(amount_to_send: u64, recipient_address: b256);
}
</code></pre>
<hr />
<p>In the first line, <code>abi Wallet {</code>, we declare the name of this <em>Application Binary Interface</em>, or ABI. We are naming this ABI <code>Wallet</code>. To import this ABI into either a script for calling or a contract for implementing, you would use <code>use wallet_abi::Wallet;</code>.</p>
<hr />
<p>In the second line,</p>
<pre><code class="language-sway">    fn receive_funds();
</code></pre>
<p>we are declaring an ABI interface surface method called <code>receive funds</code> which, when called, should receive funds into this wallet. Note that we are simply defining an interface here, so there is no <em>function body</em> or implementation of the function. We only need to define the interface itself. In this way, ABI declarations are similar to <a href="sway-on-chain/../advanced/traits.html">trait declarations</a>. This ABI method does not take any parameters.</p>
<hr />
<p>In the third line,</p>
<pre><code class="language-sway">    fn send_funds(amount_to_send: u64, recipient_address: b256);
</code></pre>
<p>we are declaring another ABI method, this time called <code>send_funds</code>. It takes two parameters: the amount to send, and the address to send the funds to.</p>
<h2 id="implementing-an-abi-for-a-smart-contract"><a class="header" href="#implementing-an-abi-for-a-smart-contract">Implementing an ABI for a Smart Contract</a></h2>
<p>Now that we've discussed how to define the interface, let's discuss how to use it. We will start by implementing the above ABI for a specific contract.</p>
<p>Implementing an ABI for a contract is accomplished with <em>impl ABI</em> syntax:</p>
<pre><code class="language-sway">impl Wallet for Contract {
    fn receive_funds() {
        if asset_id == ETH_ID {
            let balance = storage.balance.write();
            deref balance = balance + coins_to_forward;
        };
    }

    fn send_funds(amount_to_send: u64, recipient_address: b256) {
        assert(sender() == OWNER_ADDRESS);
        assert(storage.balance.read() &gt; amount_to_send);
        let balance = storage.balance.write();
        deref balance = balance - amount_to_send;
        transfer_coins(asset_id, recipient_address, amount_to_send);
    }
}
</code></pre>
<p>You may notice once again the similarities between <a href="sway-on-chain/../advanced/traits.html">traits</a> and ABIs. And, indeed, as a bonus, you can specify methods in addition to the interface surface of an ABI, just like a trait. By implementing the methods in the interface surface, you get the extra method implementations For Free™.</p>
<p>Note that the above implementation of the ABI follows the <a href="https://docs.soliditylang.org/en/v0.6.11/security-considerations.html#re-entrancy">Checks, Effects, Interactions</a> pattern.</p>
<h2 id="calling-a-smart-contract-from-a-script"><a class="header" href="#calling-a-smart-contract-from-a-script">Calling a Smart Contract from a Script</a></h2>
<p>Now that we have defined our interface and implemented it for our contract, we need to know how to actually <em>call</em> our contract. Let's take a look at a contract call:</p>
<pre><code class="language-sway">script;

use wallet_abi::Wallet;
use wallet_abi::SendFundsRequest;
use std::consts::ETH_ID;

fn main() {
    let contract_address = 0x9299da6c73e6dc03eeabcce242bb347de3f5f56cd1c70926d76526d7ed199b8b;
    let caller = abi(Wallet, contract_address);
    let amount_to_send = 200;
    let recipient_address: 0x9299da6c73e6dc03eeabcce242bb347de3f5f56cd1c70926d76526d7ed199b8b;
    caller.send_funds{gas: 10000, coins: 0, asset_id: ETH_ID}(amount_to_send, recipient_address);
}
</code></pre>
<p>The main new concept is the <em>abi cast</em>: <code>abi(AbiName, contract_address)</code>. This returns a <code>ContractCaller</code> type which can be used to call contracts. The methods of the ABI become the methods available on this contract caller: <code>send_funds</code> and <code>receive_funds</code>. We then directly call the contract ABI method as if it was just a regular method. You also have the option of specifying the following special parameters inside curly braces right before the main list of parameters:</p>
<ol>
<li><code>gas</code>: represents the gas being forwarded to the contract when it is called.</li>
<li><code>coins</code>: represents how many coins are being forwarded with this call.</li>
<li><code>asset_id</code>: represents the ID of the <em>asset type</em> of the coin being forwarded.</li>
</ol>
<p>Each special parameter is optional and assumes a default value when skipped.</p>
<h1 id="libraries"><a class="header" href="#libraries">Libraries</a></h1>
<p>Libraries in Sway are files used to define new common behavior. An example of this is the <a href="https://github.com/FuelLabs/sway-lib-core">Sway Core Library</a> which outlines various methods that the <code>u64</code> type implements.</p>
<h2 id="writing-libraries"><a class="header" href="#writing-libraries">Writing Libraries</a></h2>
<p>Functions in libraries can also read from storage and interact with the state. Libraries are denoted using the <code>library</code> keyword at the beginning of the file, followed by a name so that they can be imported. E.g. <code>library foo;</code>.</p>
<pre><code class="language-sway">library my_library;
</code></pre>
<p>A good reference library to use when learning library design is the <a href="https://github.com/FuelLabs/sway-lib-core">Sway Core Library</a>. The <code>add</code> function interface is defined via the <code>Add</code> trait and then implemented for <code>u64</code>. This attaches this <code>add</code> function to the type so that, when the trait is imported, <code>u64</code>s can utilize the <code>add</code> function.</p>
<pre><code class="language-sway">pub trait Add {
    fn add(self, other: Self) -&gt; Self;
}

impl Add for u64 {
    fn add(self, other: Self) -&gt; Self {
        asm(r1: self, r2: other, r3) {
            add r3 r2 r1;
            r3: u64
        }
    }
}
</code></pre>
<p>This snippet defines the trait <code>Add</code>, then implements it for the <code>u64</code> type by providing a function body. This gives all <code>u64</code>s the <code>add</code> function, which is inserted at compile time when you use the <code>+</code> operator in Sway. Libraries can export more than functions, though. You can also use libraries to just export types like below.</p>
<pre><code class="language-sway">pub struct MyStruct {
    field_one: u64,
    field_two: bool,
}
</code></pre>
<p>Libraries are composed of just a <code>Forc.toml</code> file and a <code>src</code> folder, unlike usual Sway projects which usually contain a <code>tests</code> folder and a <code>Cargo.toml</code> file as well. An example of a Library's <code>Forc.toml</code>: </p>
<pre><code class="language-toml=">[project]
authors = [&quot;Fuel Labs &lt;contact@fuel.sh&gt;&quot;]
entry = &quot;lib.sw&quot;
license = &quot;Apache-2.0&quot;
name = &quot;lib-std&quot;

[dependencies]
&quot;core&quot; = { git = &quot;http://github.com/FuelLabs/sway-lib-core&quot; }
</code></pre>
<p>which denotes the author, an entry file, the name by which it can be imported, and any dependencies. For large libraries, it is recommended to have a <code>lib.sw</code> entry point re-export all other sub-libraries. For example, the <code>lib.sw</code> of the standard library looks like:</p>
<pre><code class="language-sway">library std;

dep block;
dep storage;
dep constants;
</code></pre>
<p>with other libraries contained in the <code>src</code> folder, like the block library (inside of <code>block.sw</code>):</p>
<pre><code class="language-sway">library block;
//! Functionality for accessing block-related data.

/// Get the current block height
pub fn height() -&gt; u64 {
    asm(height) {
        bhei height;
        height: u64
    }
}
</code></pre>
<p>The <code>dep</code> keyword in the main library includes a dependency on another library, making all of its items (such as functions and structs) accessible from the main library. The <code>dep</code> keyword simply makes the library a dependency and fully accessible within the current context.</p>
<h2 id="using-libraries"><a class="header" href="#using-libraries">Using Libraries</a></h2>
<p>Libraries can be imported using the <code>use</code> keyword and with a <code>::</code> separating the name of the library and the import.</p>
<p>Here is an example of importing storage and its related functions from the standard library.</p>
<pre><code class="language-sway">use std::storage::*;
</code></pre>
<p>Wildcard imports using <code>*</code> are supported, but it is always recommended to use explicit imports where possible.</p>
<h1 id="scripts"><a class="header" href="#scripts">Scripts</a></h1>
<p>A script is deployed bytecode on the chain which executes once to perform some task. It does not represent ownership of any resources and it cannot be called by a contract. A script can return a single value of any type.</p>
<p>Scripts are state-aware in that while they have no persistent storage (because they only exist during the transaction) they can call contracts and act based upon the returned values and results.</p>
<p>Under the hood, the Rust and TypeScript SDK wrap all smart contract calls from EOAs with scripts that contain minimal code to make the call and forward script data as call parameters.</p>
<p>This example script calls a contract.</p>
<pre><code class="language-sway">script;

use example_contract::MyContract;

struct InputStruct {
    field_1: bool,
    field_2: u64,
}

// All scripts require a main function.
fn main () {
    let x = abi(MyContract, 0x8900c5bec4ca97d4febf9ceb4754a60d782abbf3cd815836c1872116f203f861);
    let asset_id = 0x7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777_7777;
    let input = InputStruct {
        field_1: true,
        field_2: 3,
    };
    x.foo(5000, 0, asset_id, input);
}
</code></pre>
<p>Scripts, similar to predicates, rely on a <code>main()</code> function as an entry point. You can call other functions defined in a script from the <code>main()</code> function or call another contract via an <a href="sway-on-chain/./smart_contracts.html#calling-a-smart-contract-from-a-script">abi cast</a>.</p>
<p>An example use case for a script would be a router that trades funds through multiple DEXes to get the price for the input asset, or a script to re-adjust a Collateralized Debt Position via a flashloan.</p>
<h1 id="predicates"><a class="header" href="#predicates">Predicates</a></h1>
<p>From the perspective of Sway, predicates are programs that return a Boolean value and which represent ownership of some resource upon execution to true. They have no access to contract storage. Here is a trivial predicate, which always evaluates to true:</p>
<pre><code class="language-sway">predicate;

// All predicates require a main function which returns a Boolean value.
fn main() -&gt; bool {
    true
}
</code></pre>
<h1 id="smart-contract-development"><a class="header" href="#smart-contract-development">Smart Contract Development</a></h1>
<ul>
<li><a href="smart-contract-development/./storage.html">Contract Storage</a></li>
<li><a href="smart-contract-development/./purity.html">Function Purity</a></li>
</ul>
<h1 id="storage"><a class="header" href="#storage">Storage</a></h1>
<p>When developing a <a href="smart-contract-development/../sway-on-chain/smart_contracts.html">smart contract</a>, you will typically need some sort of persistent storage. In this case, persistent storage, often just called <em>storage</em> in this context, is a place where you can store values that are persisted inside the contract itself. This is in contrast to a regular value in <em>memory</em>, which disappears after the contract exits.</p>
<p>Put in conventional programming terms, contract storage is like saving data to a hard drive. That data is saved even after the program which saved it exits. That data is persistent. Using memory is like declaring a variable in a program: it exists for the duration of the program and is non-persistent.</p>
<p>Some basic use cases of storage include declaring an owner address for a contract and saving balances in a wallet.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<h3 id="declaration"><a class="header" href="#declaration">Declaration</a></h3>
<p>The syntax of declaring storage space in Sway looks like this:</p>
<pre><code class="language-sway">storage {
    owner: b256,
}
</code></pre>
<p>It is very similar to a struct declaration, except with storage, you also have the option to specify an initial value:</p>
<pre><code class="language-sway">storage {
    owner: 0xeeb578f9e1ebfb5b78f8ff74352370c120bc8cacead1f5e4f9c74aafe0ca6bfd,
}
</code></pre>
<p>This value is passed as a part of the transaction, which initializes storage upon contract deployment.</p>
<h3 id="access"><a class="header" href="#access">Access</a></h3>
<p>Storage access should be minimized, as it incurs a larger performance and gas cost than regular memory access. There are two types of storage access: <em>reading</em> and <em>writing</em>.</p>
<h4 id="reading-from-storage"><a class="header" href="#reading-from-storage">Reading from Storage</a></h4>
<p>Reading from storage is less expensive than writing. To read a value from storage, use the <code>.read()</code> method:</p>
<pre><code class="language-sway">storage {
    owner: b256
}

impure fn get_owner() -&gt; ref b256 {
    storage.owner.read()
}
</code></pre>
<p>This returns an immutable reference to a <code>b256</code> which is held in storage. The <code>read()</code> method itself copies the value from storage and returns a pointer to it to save on actual storage read opcodes, which are expensive. <strong>This means that writing to a storage value will not update other variables that are holding references to that value acquired via <code>read()</code></strong>. If you'd like an actual <code>StorageRef</code> to the value itself, which does <em>not</em> copy the value and instead incurs a storage read cost on every access, use <code>.direct_read()</code>.</p>
<h4 id="writing-to-storage"><a class="header" href="#writing-to-storage">Writing to Storage</a></h4>
<p>Writing to storage is accomplished with the <code>.write()</code> method. The <code>.write()</code> method returns a special kind of mutable reference, called a <code>MutStorageRef</code>, which mutates storage directly upon every write. Writing to values of this type costs more gas than usual and should be minimized.</p>
<pre><code class="language-sway">contract;

storage {
    owner: b256
}

impure fn main() {
    let mutable_owner_ptr = write_owner();
    deref mutable_owner_ptr = 0x27829e78404b18c037b15bfba5110c613a83ea22c718c8b51596e17c9cb1cd6f;
}

impure fn write_owner() -&gt; MutStorageRef&lt;b256&gt; {
    storage.owner.write()
}
</code></pre>
<p>Note that to write to a mutable reference, you must dereference it first. See <a href="smart-contract-development/../basics/reference_types.html">the chapter on reference types</a> for more information on reference types in general..</p>
<h1 id="purity"><a class="header" href="#purity">Purity</a></h1>
<p>A function is <em>pure</em> if it does not access any <a href="smart-contract-development/./storage.html">persistent storage</a>. Conversely, the function is <em>impure</em> if it does access any storage. Naturally, as storage is only available in smart contracts, impure functions cannot be used in predicates, scripts, or libraries. A pure function cannot call an impure function.</p>
<p>Functions are pure by default but can be opted in to impurity via the <code>impure</code> keyword<sup class="footnote-reference"><a href="#1">1</a></sup>:</p>
<pre><code class="language-sway">// an impure function
impure fn foo() {
    does_something_with_storage();
}

// a pure function, as there is no impure specification.
fn bar() {}
</code></pre>
<p>A pure function gives you some guarantees: you will not incur excessive storage gas costs, the compiler can apply additional optimizations, and they are generally easy to reason about and audit. <a href="https://docs.soliditylang.org/en/v0.8.10/contracts.html#pure-functions">A similar concept exists in Solidity</a>. Note that Solidity refers to contract storage as <em>contract state</em>, and in the Sway/Fuel ecosystem, these two terms are largely interchangeable.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>This may be changed in the future to an annotation, like <code>#[impure]</code>, or something else. Don't get too attached to this keyword.</p>
</div>
<h1 id="advanced-concepts"><a class="header" href="#advanced-concepts">Advanced Concepts</a></h1>
<p>Advanced concepts.</p>
<ul>
<li><a href="advanced/./generic_types.html">Generic Types</a></li>
<li><a href="advanced/./traits.html">Traits</a></li>
<li><a href="advanced/./trait_constraints.html">Trait Constraints</a></li>
<li><a href="advanced/./assembly.html">Assembly</a></li>
</ul>
<h1 id="generic-types"><a class="header" href="#generic-types">Generic Types</a></h1>
<h2 id="basics-1"><a class="header" href="#basics-1">Basics</a></h2>
<p>In Sway, generic types follow a very similar pattern to those in Rust. Let's look at some example syntax,
starting with a generic function:</p>
<pre><code class="language-sway">fn noop&lt;T&gt;(argument: T) -&gt; T {
  argument
}
</code></pre>
<p>Here, the <code>noop()</code> function trivially returns exactly what was given to it. <code>T</code> is a <em>type parameter</em>, and it says
that this function exists for all types T. More formally, this function could be typed as:</p>
<pre><code class="language-math">noop :: ∀T. T -&gt; T
</code></pre>
<p>Generic types are a way to refer to types <em>in general</em>, meaning without specifying a single type. Our <code>noop</code> function
would work with any type in the language, so we don't need to specify <code>noop(argument: u8) -&gt; u8</code>, <code>noop(argument: u16) -&gt; u16</code>, etc.</p>
<h2 id="code-generation"><a class="header" href="#code-generation">Code Generation</a></h2>
<p>One question that arises when dealing with generic types is: how does the assembly handle this? There are a few approaches to handling
generic types at the lowest level. Sway uses a technique called <a href="https://en.wikipedia.org/wiki/Monomorphization">monomorphization</a>. This
means that the generic function is compiled to a non-generic version for every type it is called on. In this way, generic functions are
purely shorthand for the sake of ergonomics.</p>
<h2 id="trait-constraints"><a class="header" href="#trait-constraints">Trait Constraints</a></h2>
<p>Important background to know before diving into trait constraints is that the <code>where</code> clause can be used to specify the required traits for the generic argument. So, when writing something like a <code>HashMap</code> you may
want to specify that the generic argument implements a <code>Hash</code> trait.</p>
<pre><code class="language-sway">fn get_hashmap_key&lt;T&gt;(Key : T) -&gt; b256
    where T: Hash
{
    // Code within here can then call methods associated with the Hash trait on Key
}
</code></pre>
<p><em><code>where</code> clauses are still work-in-progress, so some <code>where</code> statements shown may not be fully implemented</em></p>
<p>Of course, our <code>noop()</code> function is not useful. Often, a programmer will want to declare functions over types which satisfy certain traits.
For example, let's try to implement the successor function, <code>successor()</code>, for all numeric types.</p>
<pre><code class="language-sway">fn successor&lt;T&gt;(argument: T)
  where T: Add
{
    argument + 1
}
</code></pre>
<p>Run <code>forc build</code>, and you will get:</p>
<pre><code class="language-sway">.. |
 9 |   where T: Add
10 |   {
11 |     argument + 1                                        
   |                ^ Mismatched types: expected type &quot;T&quot; but saw type &quot;u64&quot;
12 |   }
13 |

</code></pre>
<p>This is because we don't know for a fact that <code>1</code>, which in this case defaulted to <code>1u64</code>, actually can be added to <code>T</code>. What if <code>T</code> is <code>f64</code>? Or <code>b256</code>? What does it mean to add <code>1u64</code> in these cases?</p>
<p>We can solve this problem with another trait constraint. We can only find the successor of some value of type <code>T</code> if that type <code>T</code> defines some incrementor. Let's make a trait:</p>
<pre><code class="language-sway">trait Incrementable {
  /// Returns the value to add when calculating the successor of a value.
  fn incrementor() -&gt; Self;
}
</code></pre>
<p>Now, we can modify our <code>successor()</code> function:</p>
<pre><code class="language-sway">fn successor&lt;T&gt;(argument: T)
  where T: Add,
        T: Incrementable
{
    argument + ~T::incrementor()
}
</code></pre>
<p><em>(There's a little bit of new syntax here. When directly referring to a type to execute a method from it, a tilde (<code>~</code>) is used. This may change in the future.)</em></p>
<h2 id="generic-structs-and-enums"><a class="header" href="#generic-structs-and-enums">Generic Structs and Enums</a></h2>
<p>Just like functions, structs and enums can be generic. Let's take a look at the standard library version of <code>Option&lt;T&gt;</code>:</p>
<pre><code class="language-sway">enum Option&lt;T&gt; {
  Some: T,
  None: ()
}
</code></pre>
<p>Just like an unconstrained generic function, this type exists for all (∀) types <code>T</code>. <code>Result&lt;T, E&gt;</code> is another example:</p>
<pre><code class="language-sway">enum Result&lt;T, E&gt; {
  Ok: T,
  Err: E
}
</code></pre>
<p>Both generic enums and generic structs can be trait constrained, as well. Consider this struct:</p>
<pre><code class="language-sway">struct Foo&lt;T&gt;
  where T: Add
{
    field_one: T
}
</code></pre>
<h2 id="type-arguments"><a class="header" href="#type-arguments">Type Arguments</a></h2>
<p>Similar to Rust, Sway has what is colloquially known as the <a href="https://github.com/rust-lang/rust/blob/e98309298d927307c5184f4869604bd068d26183/src/test/ui/parser/bastion-of-the-turbofish.rs">turbofish</a>. The turbofish looks like this: <code>::&lt;&gt;</code> (see the little fish with bubbles behind it?). The turbofish is used to annotate types in a generic context. Say you have the following function:</p>
<pre><code class="language-sway">fn foo&lt;T, E&gt;(t: T) -&gt; Result&lt;T, E&gt; {
  Result::Ok(t)
}
</code></pre>
<p>In this code example, which is admittedly asinine, you can't possibly know what type <code>E</code> is. You'd need to provide the type manually, with a turbofish:</p>
<pre><code class="language-sway">fn foo&lt;T, E&gt;(t: T) -&gt; Result&lt;T, E&gt; {
  Result::&lt;T, MyErrorType&gt;::Ok(t)
}
</code></pre>
<p>It is also common to see the turbofish used on the function itself:</p>
<pre><code class="language-sway">fn main() {
  foo::&lt;Bar, Baz&gt;()
}
</code></pre>
<h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<h2 id="declaring-a-trait"><a class="header" href="#declaring-a-trait">Declaring a Trait</a></h2>
<p>A <em>trait</em> opts a type into a certain type of behavior or functionality that can be shared among types. This allows for easy reuse of code and generic programming. If you have ever used a typeclass in Haskell, a trait in Rust, or even an interface in Java, these are similar concepts.</p>
<p>Let's take a look at some code:</p>
<pre><code class="language-sway">trait Compare {
    fn equals(self, b: Self) -&gt; bool;
} {
    fn not_equals(self, b: Self) -&gt; bool {
        !equals(self.equals(b))
    }
}
</code></pre>
<p>We have just declared a trait called <code>Compare</code>. After the name of the trait, there are two <em>blocks</em> of code (a <em>block</em> is code enclosed in <code>{</code> curly brackets <code>}</code>). The first block is the <em>interface surface</em>. The second block is the <em>methods</em> provided by the trait. If a type can provide the methods in the interface surface, then it gets access to the methods in the trait for free! What the above trait is saying is: if you can determine if two values are equal, then for free, you can determine that they are not equal. Note that trait methods have access to the methods defined in the interface surface.</p>
<h2 id="implementing-a-trait"><a class="header" href="#implementing-a-trait">Implementing a Trait</a></h2>
<p>Ok, so I know that numbers can be equal. I want to implement my <code>Compare</code> trait for <code>u64</code>. Let's take a look at how that is done:</p>
<pre><code class="language-sway">impl Compare for u64 {
    fn equals(self, b: Self) -&gt; bool {
        self == b
    }
}
</code></pre>
<p>The above snippet declares all of the methods in the trait <code>Compare</code> for the type <code>u64</code>. Now, we have access to both the <code>equals</code> and <code>not_equals</code> methods for <code>u64</code>, as long as the trait <code>Compare</code> is in scope.</p>
<h2 id="supertraits"><a class="header" href="#supertraits">Supertraits</a></h2>
<p>When using multiple traits, scenarios often come up where one trait may require functionality from another trait. This is where supertraits come in as they allow you to require a trait when implementing another
trait (ie. a trait with a trait). A good example of this is the <code>Ord</code> trait of the <code>core</code> library of Sway. The <code>Ord</code> trait requires the <code>Eq</code> trait, so <code>Eq</code> is kept as a separate trait as one may decide to implement <code>Eq</code>
without implementing other parts of the <code>Ord</code> trait. </p>
<pre><code class="language-sway">
trait Eq {
    fn equals(self, b: Self) -&gt; bool;
}

trait Ord: Eq {
    fn gte(self, b: Self) -&gt; bool;
}

impl Ord for u64 {
    fn gte(self, b: Self) -&gt; bool {
        // As `Eq` is a supertrait of `Ord`, `Ord` can access the equals method
        self.equals(b) || self.gt(b)
    }
}
</code></pre>
<p>To require a supertrait, add a <code>:</code> after the trait name and then list the traits you would like to require and separate them with a <code>+</code>.</p>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<h3 id="custom-types-structs-enums"><a class="header" href="#custom-types-structs-enums">Custom Types (structs, enums)</a></h3>
<p>Often, libraries and APIs have interfaces that are abstracted over a type that implements a certain trait. It is up to the consumer of the interface to implement that trait for the type they wish to use with the interface. For example, let's take a look at a trait and an interface built off of it.</p>
<pre><code class="language-sway">library games;

pub enum Suit {
    Hearts: (),
    Diamonds: (),
    Clubs: (),
    Spades: ()
}

pub trait Card {
    fn suit(self) -&gt; Suit;
    fn value(self) -&gt; u8;
}

fn play_game_with_deck&lt;T&gt;(a: Vec&lt;T&gt;) where T: Card {
    // insert some creative card game here
  }
</code></pre>
<p>Now, if you want to use the function <code>play_game_with_deck</code> with your struct, you must implement <code>Card</code> for your struct. Note that the following code example assumes a dependency <em>games</em> has been included in the <code>Forc.toml</code> file.</p>
<pre><code class="language-sway">script;
use games::*;
struct MyCard {
    suit: Suit,
    value: u8
}

impl Card for MyCard {
    fn suit(self) -&gt; Suit {
        self.suit
    }
    fn value(self) -&gt; u8 {
        self.value
    }
}

fn main() {
    let mut i = 52;
    let mut deck: Vec&lt;MyCard&gt; = Vec::with_capacity(50);
    while i &gt; 0 {
        i = i - 1;
        deck.push(MyCard { suit: generate_random_suit(), value: i % 4}
    }
    play_game_with_deck(deck);
}

fn random_suit(i: u64) -&gt; Suit {
  [ ... ]
}
</code></pre>
<h1 id="trait-constraints-1"><a class="header" href="#trait-constraints-1">Trait Constraints</a></h1>
<p>Trait constraints on generics are currently a work in progress.</p>
<h1 id="inline-assembly-in-sway"><a class="header" href="#inline-assembly-in-sway">Inline Assembly in Sway</a></h1>
<p>While many users will never have to touch assembly language while writing sway code, it is a powerful tool that enables many advanced use-cases (ie: optimizations, building libraries, etc).</p>
<h2 id="asm-block"><a class="header" href="#asm-block">ASM Block</a></h2>
<p>In Sway, the way we use assembly inline is to declare an asm block like this:</p>
<pre><code class="language-sway">asm() {...}
</code></pre>
<p>Declaring an <code>asm</code> block is similar to declaring a function.
We can specify register names to operate on as arguments, we can perform operations within the block, and we can return a value.
Here's an example showing what this might look like:</p>
<pre><code class="language-sway">pub fn add_1(num: u32) -&gt; u32 {
    asm(r1: num, r2) {
        add r2 r1 one;
        r2: u32
    }
}
</code></pre>
<p>Note that in the above example:</p>
<ul>
<li>we initialized the register <code>r1</code> with the value of <code>num</code>.</li>
<li>we declared a second register <code>r2</code> (you may choose any register names you want).</li>
<li>we use the <code>add</code> opcode to add <code>one</code> to the value of <code>r1</code> and store it in <code>r2</code>.</li>
<li><code>one</code> is an example of a &quot;reserved register&quot;, of which there are 16 in total. Further reading on this is linked below under &quot;Semantics&quot;.</li>
<li>we return <code>r2</code> &amp; specify the return type as being u32 (the return type is u64 by default).</li>
</ul>
<h2 id="helpful-links"><a class="header" href="#helpful-links">Helpful Links</a></h2>
<p>For examples of assembly in action, check out the <a href="https://github.com/FuelLabs/sway-lib-std">Sway standard library</a>.</p>
<p>For a complete list of all instructions supported in the FuelVM: <a href="https://github.com/FuelLabs/fuel-specs/blob/master/specs/vm/opcodes.md">Instructions</a>.</p>
<p>And to learn more about the FuelVM semantics: <a href="https://github.com/FuelLabs/fuel-specs/blob/master/specs/vm/main.md#semantics">Semantics</a>.</p>
<h1 id="blockchain-concepts"><a class="header" href="#blockchain-concepts">Blockchain Concepts</a></h1>
<p>These are some concepts related to the FuelVM and Fuel ecosystem that you may utilize when writing Sway.</p>
<ul>
<li><a href="blockchain-concepts/./blockchain_types.html">Blockchain Types</a></li>
<li><a href="blockchain-concepts/./identifiers.html">Identifiers</a></li>
<li><a href="blockchain-concepts/./native_assets.html">Native Assets</a></li>
</ul>
<h1 id="blockchain-types"><a class="header" href="#blockchain-types">Blockchain Types</a></h1>
<p>Sway has a selection of types provided via the standard library (<a href="https://github.com/FuelLabs/sway-lib-std"><code>lib-std</code></a>) which both add a degree of type-safety, as well as make the intention of the developer more clear.</p>
<h2 id="address-type"><a class="header" href="#address-type"><code>Address</code> Type</a></h2>
<p>The <code>Address</code> type is a type-safe wrapper around the primitive <code>b256</code> type. Unlike Ethereum, an address <strong>never</strong> refers to a deployed smart contract (see the <code>ContractId</code> type below). An <code>Address</code> can be either the hash of a public key (effectively an <a href="https://ethereum.org/en/whitepaper/#ethereum-accounts">externally owned account</a> if you're coming from Ethereum) or the hash of a <a href="blockchain-concepts/../sway-on-chain/predicates.html">predicate</a>. Addresses own UTXOs.</p>
<p>An <code>Address</code> is implemented as follows.</p>
<pre><code class="language-sway">pub struct Address {
    value: b256,
}
</code></pre>
<p>Casting between the <code>b256</code> and <code>Address</code> types must be done explicitly:</p>
<pre><code class="language-sway">let my_number: b256 = 0x000000000000000000000000000000000000000000000000000000000000002A;
let my_address: Address = ~Address::from(my_number);
let forty_two: b256 = my_address.into();
</code></pre>
<h2 id="contractid-type"><a class="header" href="#contractid-type"><code>ContractId</code> Type</a></h2>
<p>The <code>ContractId</code> type is a type-safe wrapper around the primitive <code>b256</code> type. A contract's ID is a unique, deterministic identifier analogous to a contract's address on Ethereum. Contracts cannot own UTXOs.</p>
<p>A <code>ContractId</code> is implemented as follows.</p>
<pre><code class="language-sway">pub struct ContractId {
    value: b256,
}
</code></pre>
<p>Casting between the <code>b256</code> and <code>ContractId</code> types must be done explicitly:</p>
<pre><code class="language-sway">let my_number: b256 = 0x000000000000000000000000000000000000000000000000000000000000002A;
let my_contract_id: ContractId = ~ContractId::from(my_number);
let forty_two: b256 = my_contract_id.into();
</code></pre>
<h1 id="identifiers"><a class="header" href="#identifiers">Identifiers</a></h1>
<p>Addresses in Sway are similar to Ethereum addresses. The two major differences are:</p>
<ol>
<li>Sway addresses are 32 bytes long (instead of 20), and</li>
<li>are computed with the SHA-256 hash of the public key instead of the keccak-256 hash.</li>
</ol>
<p>Contracts, on the other hand, are uniquely identified with a contract ID rather than an address. A contract's ID is also 32 bytes long and is calculated <a href="https://github.com/FuelLabs/fuel-specs/blob/master/specs/protocol/identifiers.md#contract-id">here</a>.</p>
<h1 id="native-support-for-multiple-asset-types"><a class="header" href="#native-support-for-multiple-asset-types">Native Support for Multiple Asset Types</a></h1>
<p>The FuelVM has built-in support for working with multiple assets.</p>
<p>What does this mean in practice?</p>
<p>As in Ethereum, sending ETH to an address or contract is an operation built into the FuelVM, meaning it doesn't rely on the existence of some token smart contract to update balances to track ownership.</p>
<p>However, unlike Ethereum, the process for sending <em>any</em> native asset is the same. This means that while you would still need a smart contract to handle the minting and burning of fungible tokens, the sending and receiving of these tokens can be done independently of the token contract.</p>
<h1 id="conventions"><a class="header" href="#conventions">Conventions</a></h1>
<ul>
<li><a href="style/./capitalization.html">Capitalization</a></li>
</ul>
<h1 id="capitalization"><a class="header" href="#capitalization">Capitalization</a></h1>
<p>In Sway, structs, traits, and enums are <code>CapitalCase</code>. Modules, variables, and functions are <code>snake_case</code>, constants are <code>SCREAMING_SNAKE_CASE</code>. The compiler will warn you if your capitalization is ever unidiomatic.</p>
<h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<ul>
<li><a href="reference/./temporary_workarounds.html">Temporary Workarounds</a></li>
<li><a href="reference/./rust_differences.html">Differences from Rust</a></li>
<li><a href="reference/./solidity_differences.html">Differences from Solidity</a></li>
<li><a href="reference/./contributing_to_sway.html">Contributing to Sway</a></li>
</ul>
<h1 id="temporary-workarounds"><a class="header" href="#temporary-workarounds">Temporary Workarounds</a></h1>
<h2 id="standard-library"><a class="header" href="#standard-library">Standard Library</a></h2>
<p>The standard library is currently not distributed with <code>forc</code> if <a href="reference/./installation.html#installing-from-cargo">installed via <code>cargo</code></a>. It must be downloaded manually or specified as a dependency in the Forc manifest file. A variation of the following must be included in your project's <code>Forc.toml</code> file:</p>
<pre><code class="language-toml">[dependencies]
core = { git = &quot;http://github.com/FuelLabs/sway-lib-core&quot;, version = &quot;v0.0.1&quot; }
std = { git = &quot;http://github.com/FuelLabs/sway-lib-std&quot;, version = &quot;v0.0.1&quot; }
</code></pre>
<p>Note that the default <code>Forc.toml</code> generated with <code>forc init</code> already includes these lines, so no further action is necessary.</p>
<h2 id="storage-variables-and-mappings"><a class="header" href="#storage-variables-and-mappings">Storage Variables and Mappings</a></h2>
<p>Storage variables (or more specifically, automatic assignment of storage slots) are not yet implemented. Storage slots will have to be assigned manually.</p>
<pre><code class="language-sway">contract;

use std::hash::*;
use std::storage::*;

abi Store {
    fn store(x: u64, y: b256);
}

// Storage slot domain separator for a primitive
const STORAGE_SLOT_PRIMITIVE: b256 = 0x0000000000000000000000000000000000000000000000000000000000000000;
// Storage slot domain separator for a mapping
const STORAGE_SLOT_MAPPING: b256 = 0x0000000000000000000000000000000000000000000000000000000000000001;

impl Store for Contract {
    fn store(x: u64, y: b256) {
        // Compute storage slot for primitive and store `x`
        let storage_slot_primitive = hash_value(STORAGE_SLOT_PRIMITIVE, HashMethod::Sha256);
        store(storage_slot_primitive, x);

        // Compute mapping slot for `y` and store `x`
        let storage_slot_mapping = hash_pair(STORAGE_SLOT_MAPPING, y, HashMethod::Sha256);
        store(storage_slot_mapping, x);
    }
}
</code></pre>
<h2 id="serialization-and-deserialization"><a class="header" href="#serialization-and-deserialization">Serialization and Deserialization</a></h2>
<p>Serialization/encoding of structures (Solidity's <code>abi.encode()</code> and <code>abi.encodePacked()</code>) is not yet implemented. Therefore, hashing an encoded struct is not possible without some manual work.</p>
<p>Serializing arbitrary structures can be accomplished manually by composition of recursive <code>hash_pair()</code> invocations. See the above example for hashing a pair of values.</p>
<h2 id="optimizer"><a class="header" href="#optimizer">Optimizer</a></h2>
<p>The optimizing pass of the compiler is not yet implemented, therefore bytecode will be more expensive and larger than it would be in production. Note that eventually the optimizer will support zero-cost abstractions, avoiding the need for developers to go down to inline assembly to produce optimal code.</p>
<h2 id="formatter"><a class="header" href="#formatter">Formatter</a></h2>
<p>Currently, we need to parse the Sway code before formatting it. Hence, <strong>the formatter cannot work on Sway code that does not parse correctly</strong>. This requirement may be changed in the future.</p>
<h1 id="differences-from-solidity"><a class="header" href="#differences-from-solidity">Differences From Solidity</a></h1>
<p>This page outlines some of the critical differences between Sway and Solidity, and between the FuelVM and the EVM.</p>
<h2 id="underlying-virtual-machine"><a class="header" href="#underlying-virtual-machine">Underlying Virtual Machine</a></h2>
<p>The underlying virtual machine targeted by Sway is the FuelVM, specified <a href="https://github.com/FuelLabs/fuel-specs">here</a>. Solidity targets the Ethereum Virtual Machine (EVM), specified <a href="https://ethereum.github.io/yellowpaper/paper.pdf">here</a>.</p>
<h2 id="word-size"><a class="header" href="#word-size">Word Size</a></h2>
<p>Words in the FuelVM are 64 bits (8 bytes), rather than the 256 bits (32 bytes) of the EVM. Therefore, primitive integers only go up to <code>u64</code>, and hashes (the <code>b256</code> type) are not in registers but rather in memory. A <code>b256</code> is therefore a pointer to a 32-byte memory region containing the hash value.</p>
<h2 id="unsigned-integers-only"><a class="header" href="#unsigned-integers-only">Unsigned Integers Only</a></h2>
<p>Only unsigned integers are provided as primitives: <code>u8</code>, <code>u16</code>, <code>u32</code>, and <code>u64</code>. Signed integer arithmetic is not available in the FuelVM. Signed integers and signed integer arithmetic can be implemented in high-level libraries if needed.</p>
<h2 id="global-revert"><a class="header" href="#global-revert">Global Revert</a></h2>
<p>Panics in the FuelVM (called &quot;reverts&quot; in Solidity and the EVM) are global, i.e. they cannot be caught. A panic will completely and unconditionally revert the stateful effects of a transaction, minus gas used.</p>
<h2 id="default-safe-math"><a class="header" href="#default-safe-math">Default Safe Math</a></h2>
<p>Math in the FuelVM is by default safe (i.e. any overflow or exception is a panic). Safety checks are performed natively in the VM implementation, rather than at the bytecode level like <a href="https://docs.soliditylang.org/en/latest/080-breaking-changes.html#silent-changes-of-the-semantics">Solidity's default safe math</a>.</p>
<h2 id="no-code-size-limit"><a class="header" href="#no-code-size-limit">No* Code Size Limit</a></h2>
<p>There is no practical code size limit to Sway contracts. The physical limit is governed by the <a href="https://github.com/FuelLabs/fuel-specs/blob/master/specs/vm/main.md#parameters"><code>VM_MAX_RAM</code> VM parameter</a>, which at the time of writing is 64 MiB.</p>
<h1 id="differences-from-rust"><a class="header" href="#differences-from-rust">Differences From Rust</a></h1>
<p>Sway shares a lot with Rust, especially its syntax. Because they are so similar, you may be surprised or caught off guard when they differ. This page serves to outline, from a high level, some of the syntactic <em>gotchas</em> that you may encounter.</p>
<h2 id="enum-variant-syntax"><a class="header" href="#enum-variant-syntax">Enum Variant Syntax</a></h2>
<p>In Rust, enums generally take one of three forms: <em>unit</em> variants, which have no inner data, <em>struct</em> variants, which contain named fields, and <em>tuple</em> variants, which contain within them a tuple of data. If you are unfamiliar with these terms, this is what they look like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// note to those skimming the docs: this is Rust syntax! Not Sway! Don't copy/paste this into a Sway program.

enum Foo {
    UnitVariant,
    TupleVariant(u32, u64, bool),
    StructVariant { 
        field_one: bool,
        field_two: bool
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In Sway, enums are simplified. Enums variants must all specify exactly one type. This type represents their interior data. This is actually isomorphic to what Rust offers, just with a different syntax. I'll now rewrite the above enum but with Sway syntax:</p>
<pre><code class="language-sway">// This is equivalent Sway syntax for the above Rust enum.
enum Foo {
    UnitVariant    : (),
    TupleVariant   : (u32, u64, bool),
    StructVariant  : MyStruct 
}

struct MyStruct {
    field_one: bool,
    field_two: bool
}
</code></pre>
<h2 id="if-expressions"><a class="header" href="#if-expressions">If Expressions</a></h2>
<p>Like Rust, ifs are expressions in Sway. What this means is you can do stuff like this:</p>
<pre><code class="language-sway">let my_data = if some_bool &lt; 10 { foo() } else { bar() };
</code></pre>
<p>In Sway, a <em>statement</em> is a <em>declaration <strong>or</strong> expression with a semicolon after it</em>. This means that you need to add a semicolon after an <code>if</code> to turn it into a statement, if it is being used for control flow:</p>
<pre><code class="language-sway">fn main() {
    if something_is_true {
        do_this();
    } else {
        do_that();
    };   // &lt;------------ note this semicolon
}
</code></pre>
<p>This need for a semicolon after if expressions to turn them into statements will be removed eventually, but it hasn't been removed yet.</p>
<h1 id="contributing-to-sway"><a class="header" href="#contributing-to-sway">Contributing To Sway</a></h1>
<p>Thanks for your interest in contributing to Sway! This document outlines the process for installing and setting up the Sway toolchain for development, as well as some conventions on contributing to Sway.</p>
<p>If you run into any difficulties getting started, you can always ask questions on our <a href="https://discord.gg/xfpK4Pe">Discord</a>.</p>
<h2 id="building-and-setting-up-a-development-workspace"><a class="header" href="#building-and-setting-up-a-development-workspace">Building and setting up a development workspace</a></h2>
<p>See the <a href="reference/../introduction/index.html">introduction</a> section for instructions on installing and setting up the Sway toolchain.</p>
<h2 id="getting-the-repository"><a class="header" href="#getting-the-repository">Getting the repository</a></h2>
<ol>
<li>Visit the <a href="https://github.com/FuelLabs/sway">Sway</a> repo and fork the project.</li>
<li>Then clone your forked copy to your local machine and get to work.</li>
</ol>
<pre><code class="language-sh">git clone https://github.com/FuelLabs/sway
cd sway
</code></pre>
<h2 id="building-and-testing"><a class="header" href="#building-and-testing">Building and testing</a></h2>
<p>The following steps will run the sway test suite and ensure that everything is set up correctly.</p>
<p>First, open a new terminal and start <code>fuel-core</code> with:</p>
<pre><code class="language-sh">fuel-core
</code></pre>
<p>Then open a second terminal, cd into the <code>sway</code> repo and run:</p>
<pre><code class="language-sh">cargo run --bin test
</code></pre>
<p>After the test suite runs, you should see:</p>
<pre><code class="language-console">Tests passed.
_n_ tests run (0 skipped)
</code></pre>
<p>Congratulations! You've now got everything setup and are ready to start making contributions.</p>
<h2 id="finding-something-to-work-on"><a class="header" href="#finding-something-to-work-on">Finding something to work on</a></h2>
<p>There are many ways in which you may contribute to the Sway project, some of which involve coding knowledge and some which do not. A few examples include:</p>
<ul>
<li>Reporting bugs</li>
<li>Adding documentation to the Sway book</li>
<li>Adding new features or bugfixes for which there is already an open issue</li>
<li>Making feature requests</li>
</ul>
<p>Check out our <a href="https://github.com/FuelLabs/sway/issues?q=is%3Aopen+is%3Aissue+label%3A%22help+wanted%22">Help Wanted</a>, <a href="https://github.com/FuelLabs/sway/issues?q=is%3Aopen+is%3Aissue+label%3A%22The+Sway+Book%22">Sway Book</a> or <a href="https://github.com/FuelLabs/sway/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22">Good First Issue</a> issues to find a suitable task.</p>
<p>If you are planning something big, for example, related to multiple components or changes current behaviors, make sure to open an issue to discuss with us before starting on the implementation.</p>
<h2 id="contribution-flow"><a class="header" href="#contribution-flow">Contribution flow</a></h2>
<p>This is a rough outline of what a contributor's workflow looks like:</p>
<ul>
<li>Make sure what you want to contribute is already tracked as an issue.
<ul>
<li>We may discuss the problem and solution in the issue.</li>
</ul>
</li>
<li>Create a Git branch from where you want to base your work. This is usually master.</li>
<li>Write code, add test cases, and commit your work.</li>
<li>Run tests and make sure all tests pass.</li>
<li>If the PR contains any breaking changes, add the breaking label to your PR.</li>
<li>Push your changes to a branch in your fork of the repository and submit a pull request.
<ul>
<li>Make sure mention the issue, which is created at step 1, in the commit message.</li>
</ul>
</li>
<li>Your PR will be reviewed and some changes may be requested.
<ul>
<li>Once you've made changes, your PR must be re-reviewed and approved.</li>
<li>If the PR becomes out of date, you can use GitHub's 'update branch' button.</li>
<li>If there are conflicts, you can merge and resolve them locally. Then push to your PR branch.
Any changes to the branch will require a re-review.</li>
</ul>
</li>
<li>Our CI system (Github Actions) automatically tests all authorized pull requests.</li>
<li>Use Github to merge the PR once approved.</li>
</ul>
<p>Thanks for your contributions!</p>
<h3 id="linking-issues"><a class="header" href="#linking-issues">Linking issues</a></h3>
<p>Pull requests should be linked to at least one issue in the same repo.</p>
<p>If the pull request resolves the relevant issues, and you want GitHub to close these issues automatically after it merged into the default branch, you can use the syntax (<code>KEYWORD #ISSUE-NUMBER</code>) like this:</p>
<pre><code>close #123
</code></pre>
<p>If the pull request links an issue but does not close it, you can use the keyword <code>ref</code> like this:</p>
<pre><code>ref #456
</code></pre>
<p>Multiple issues should use full syntax for each issue and separate by a comma, like:</p>
<pre><code>close #123, ref #456
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
